RELEASE NOTES COMPILER HC12

RELEASE NOTES CHC12 V5.0.46
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.

List of fixed Bugs
- ENGR00279318 fix - the destructor of a wrong class is called when the stack/temporary location is shared by multiple objects of
	different classes/type. This behaviour was caused by the reuse of a temporary location that points to a c++ class object 
	(witout changing the location's type to the new type to be stored in the temporary).

	class T10
	{
		public:
			int left;
			T10(int l): left(l) {}
	};

	class T11
	{
		public:
			T11()  {...}
			~T11() {...}
			T11 doSomething() {return T11();}
			const T11 & operator =(const T11& t) { return *this;}
	};

	void test8(void) {
	{
		T11 t;
		t = t.doSomething();
	}
	{
		T10(0);
	}
	{
		T10(0);
	}
  

List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.45
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.

List of fixed Bugs
- ENGR00226149 - internal error when compiling a conditional expression having a pointer-to-member as one of it's operands.
- ENGR00195981 - internal error when compiling a c++ class that has a virtual destructor.
- ENGR00242015 - wrong computation of the stack consumption when certain optimizations are enabled  

List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.44
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.

List of fixed Bugs
- ENGR00220451, register-to-register spill incorrectly overwrites index register 'X' which contains 
  the offset part of a far address:
  static unsigned char calculateEndFromStart(unsigned int startAddr, unsigned char dataSize, unsigned int *__rptr endAddr) {
      unsigned int tmp = startAddr + dataSize - 1; /* D spilled to X */
      if (tmp <= 3359 && tmp >= 360) {
          *endAddr = tmp; /* it is assumed that X contains the offset part of the 24-bit address stored in pointer 'endAddr' (no longer true following the spill) */
          return 0;
      }
    else {
		...
      }
  }  

List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.43
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
-

List of fixed Bugs
- MTWX48355, incorrect spill code generated when compiling with option -Or.
- MTWX45804, internal compiler error on incorrect switch expression
- MTWX45942, error C1014 ('Integral type expected or enum value out of range') unexpectedly 
  reported on the following enumerated type definition:
  #pragma OPTION ADD __DO_NOT_CHECK_SCOPE__ OPT_TUE2 "-Tue2"
  enum some_enum{
    A = -1, /* error */
    ...
  };
- ENGR00212847 - incorrect spill decision for a code that contains switch statements with some spare values:

	char local_val1 = add();
	char local_val2 = sub();

	switch(switch_selector_var){
		case 0:
			if((local_val1 && local_val2 ==0) || local_val1 == 0)
				value += 1;
			break;
		case 1:
			break;
		case 2:value += 3;break;
		case 3:value += 4;break;
		case 15:value += 6;break;
		case 16:value += 7;break;
	}
	
	switch_selector_var variable is spilled on the same location(same stack location) as local_val1;

List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.42
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- Support for computing the maximum stack consumption that might be used at runtime by an application.
  The stack consumption information is dumped by the linker in the *.map file by activating the option -StackConsumption.
- Environment variable expansion in the command line (also applies to command line arguments 
  provided via the -ArgFile option). The syntax is $(ENV_VAR) or ${ENV_VAR}. 
  Example: chc12 -I{INC_PATH} test.c
- Support for explicitly qualifying a class with modifier '__far' - so as to instruct the 
  compiler to handle 'this' as a far pointer. It addresses issue MTWX43213.
  Example:
  class B __ far 
  { ... }
  class A __far : B
  { ... }
  Note. In case of inheritance, in order for the generated code to work properly, one should 
  qualify both the derived and the base class. If the modifier has been used for the derived 
  class only, the compiler will report the following warning:
  C1145: Class '%s', qualified with modifier __far, inherits from non-qualified base class '%s'

List of fixed Bugs
- MTWX43662, given two different source files that include the same C++ class declaration header, 
  the compiler-created assignment operator contains different code, depending on the including 
  source file.
- MTWX42909, unexpected token error (C2450) on compiling the following code:
  #define VARNAME( infix, var) myprefix_##infix##_##var
  unsigned char VARNAME(31_z, myvar);
- MTWX42835, error C3400 unexpectedly reported in an array initialization with both address and numeric 
  components:
  static const FuncPtr arr[2] =
  {
      (FuncPtr) &func,
	  (FuncPtr) 0xffffffffu  /* error C3400 (shoud be reported for address components only) */
  };

List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.41
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- #pragma PAGE_UPDATE: this pragma allows temporarly disabling the updates to a page register.
  Syntax:   #pragma PAGE_UPDATE <PAGE_REG> ON|OFF. Currently the only supported setting for 
  PAGE_REG is "__GPAGE_REG". ). If the #pragma state is ON, the compiler will function as it does 
  currently emitting code for updating the page register whenever required. It is the user's 
  responsibility to ensure that throughout the execution of the functions that are compiled with  
  #pragma PAGE_UPDATE OFF the page register is not altered. This pragma can only be applied to 
  entire functions. Even if it is inserted within a function’s body, it will affect the entire 
  function.
- Optimized code generation for 32-bit shift operations with constant shift count when the main 
  optimization target is set to execution time (-Ot).
- New peephole optimization: removes bitwise logical inclusive OR instructions in which the memory
  location operand is constant 0 ("ORAA/ORAB/ORX/ORY #0"). This optimization can be disabled with 
  compiler option "-OnP=z". It addresses issue MTWX41078.
- MISRA-C:2004 compliant libraries.

List of fixed Bugs
- MTWX40051, no support for setting the value of PPAGE_ADDR (used in datapage.c) via a commmand line macro definition.
- MTWX40986, incorrect code generated for a conditional expression, when the -Or compiler option is used:
  #define  Toupper(c)  (Islower(c) ? ((c) - 'a' + 'A') : (c))
  char *l;
  ...
  static unsigned int foo(void)
  {
    unsigned int w;
    char tmp;
    w=0;
    do
    {
      tmp=(char)Toupper(*l);
	  ...
    }while (*l && (*l!=' '));
	...
  }
  Given the snippet above, the compiler generates code that is incorrect:
   20:    w=0;
  0002 c7           [1]     CLRB  
  0003 87           [1]     CLRA  
   21:    do
   22:    {
   23:       tmp=(char)Toupper(*l);
  0004 3b           [2]     PSHD  
  0005 e6fb0000     [6]     LDAB  [l,PCR]
  0009 6b87         [2]     STAB  7,SP
  000b ce0000       [2]     LDX   #_ctype
  000e 3a           [3]     PULD  
  000f 0fe50208     [4]     BRCLR B,X,#2,*+12 ;abs = 001b
  ...
  Just before the BRCLR instruction, 'w' is restored into register D, overwriting the contents of B.
- MTWX41020, warning C1805 emitted, instead of error C12010, for pointer conversions that are not 
  supported in global pointer initialization. These are the pointer conversions that involve different 
  source/destination address spaces (i.e. the destination address space is global and the source address 
  space is logical, or vice-versa), and the address to initialize the pointer with is provided in the 
  form of a constant expression (as opposed to taking the address of a variable or using another pointer):
  int * __far p1 = (int * __far)(int * __rptr)(0x11000); /* conversion not supported => error C12010 */
  int * __far p2 = (int * __far)(int * __rptr)&x;        /* conversion supported */
  int * __far p3 = (int * __far)(int * __rptr)p;         /* conversion supported */
- MTWX41839, incorrect code generated for an assignment with the left-hand-side consisting of a shift-left 
  by 8 bits operation, and the righ-hand-side containing a truncation from 'long *' to 'short *':
  long l;
  short a;   
  *((short*)&l +1) = a ;      /* OK */
  *((short*)&l + 1) = a << 8; /* exposes the issue */
  Given the snippet above, the compiler generates the following code:
   46: 	    *((short*)&l +1) = a ;       /* OK */
  000c ed84         [3]     LDY   4,SP
  000e 6d82         [2]     STY   2,SP
   48:     *((short*)&l +1) = a << 8;    /* exposes the issue */
  0010 e685         [3]     LDAB  5,SP
  0012 6b80         [2]     STAB  0,SP
  0014 6981         [2]     CLR   1,SP
- MTWX42128, incorrect resolution for a call to a virtual function which is overloaded in both the base class 
  and the derived class.
- MTWX40717, virtual table pointers (vptr) handled as __far by default.
  Workaround: use option "-Qvptrnone".
- MTWX36892, no C1830("Modifiable lvalue expected") compiler error on the following assignment: 
  typedef struct 
  {
    const int x;
    int *pointer;
  }node;
  node var1 = {w,&y};
  node var2 = {z,&x};
  void test(void) 
  {
	var1 = var2; /* error C1830 expected */
  }
- MTWX38997, internal error on compiling a C++ class definition, when the same name is used for both the class member and
  its initializer in the constructor intialization list:
  A::A(const char *fileName) : fileName(fileName)   /* internal error */
  {
  }
  B::B(const char *fileName_) : fileName(fileName_) /* no error */
  {
  }
- MTWX39268, linker error on multiple instances of the same C++ template class, when members are initialized in the constructor 
  initialization list (rather than within the constructor body):
  template <class elemType>
  class Array
  { 
  public: 
    Array():_size(0)  { }  
    int _size;
  }; 
  Array<int> *pi;
  Array<float> *pf;
- MTWX33490, no compiler error on initialization of an array with 0 elements:
  #define TSIZE 0
  unsigned int t[TSIZE]={0x5a5a, 0xAAAA, 0x1234, 0x5678}; 

List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.40
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.

List of fixed Bugs
- MTWX35998, incorrect code generated by the compiler when sub-functions are created from common
  code. This occurs when the common code contains SP-relative accesses with negative offsets.
- MTWX34698, internal error on illegal structure initialization (too many elements in the
  initializer for a structure field of scalar type):
  typedef struct
  {
    uint16 x;
    char *buffer;
    uint16 y;
  } SomeStruct;
  static const SomeStruct s =
  {
    /* an internal error occurs because of the illegal initializer below */
    {
      5, "abc", 10
    }
  }
- MTWX36601, invalid address of the PPAGE register for derivative S12P128.  For S12P128,
  the PPAGE address should be 0x15. The user is expected to provide this value to the
  compiler via the -CpPPAGE command line option (-CpPPAGE=0x15). Despite the option, the
  PPAGE address stays 0x30, which is incorrect.
- MTWX38914, incorrect initialization of the virtual table pointer, when option -Qvtpfar is used:
  class SomeClass
  {
  private:
    int data;
  public:
    SomeClass()
    {
	  data = 1;
    };
	virtual void meth();
  };
  The virtual table pointer must be initialized with the address of the virtual function table.
  Instead, the pointer is set to an incorrect value, with its MS byte unexpectedly cleared:
  CLR   0,X
  LDY   @___vtbl__SomeClass
  STY   1,X
- MTWX38994, incorrect code generated when using the address of an array which is
  assigned an absolute address using the global variable address modifier (@). 
  Example:
  unsigned char arr[] @ 0x2000 = 0x55;
  unsigned int a  = 0x2044;
  unsigned int test;
  
  void main(void) {
    test = (unsigned int) (((unsigned int)a) & ((unsigned int)&arr));
  }
  
List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.39
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.
List of fixed Bugs

- MTWX34794, incorrect code generated for accessing the element of an array which was passed to
  the current function as a parameter, with the array size explicitly specified in the formal
  parameter declaration.
  Example:

  SomeStruct v[10];
  void Test(SomeStruct p[10]) {
  int index;
  for (index = 0; index < 10; index++) {
	test_value = (&p[index])->a; /* address computation is disrupted for the current array element
	                                because of unexpected sign extension operation
								 */
	}
	...
  }
  ...
  Test(v);
- MTWX35988, incorrect code generated for passing arguments to a function, when the function call is preceded by a
  statement which translates to an EMACS instruction.
  Example:

  long int mult16s(short int a, short int b)
  {
    ...
	char aL8 = (char) (a & 0x0FF);
	char bH8 = (char) (b >> 8);
	...
	result32 += (tmp16 << 8); /* an EMACS instruction is generated */
	tmp16 = mult8su(bH8, aL8); /* the generated argument passing code is not correct */
	...
  }
- MTWX35733, error reported for the snippet below, when the source file has UNIX-style line terminators:
  #if 0
  /
  #endif
- MTWX34866, inefficient code generated when modifier __DIRECT_SEG is used with pragma DATA_SEG.

List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.38
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- MTWX32922: some HCS12 derivatives now have a DIRECT register. Enabling -CpDIRECT for these derivatives 
  too.
- New compiler option (-MemBanker) to enable compile-time analysis that is required by the MemoryBanker.
- New compiler options to force default flags for constant/non-constant data:
    -ConstQualiFar     : forces all constans to be treated as far.
    -ConstQualiNear    : forces all constans to be treated as near.
    -NonConstQualiFar  : forces all non-constans to be treated as far.
    -NonConstQualiNear : forces all non-constans to be treated as near.
  Options -ConstQualiNear and -NonConstQualiNear do not touch function parameters, i.e. if the
  large memory model is used, all parameters, either const or non-const, that are not explicitly
  qualified, are always passed as far.
- New compiler message (C12001) to warn against possible accesses to non-constant data via
  pointers to constant data - if pointers are optimized using -ConstQualiNear, such accesses
  cause loss of data.
  Message C12001 will be reported for each const member of a non-const data structure instance
  in the following format:
  C12001: '<member>' is a const member of non-const instance '<instance>' of structure '<structure>'
  (possible loss of data at access to non-constant data through pointer to constant data, when pointer
  optimization is enabled via -ConstQualiNear)
- New pointer qualifier to designate specific data pointers as full 24-bit far pointers: __far24.
  Addition to and subtraction from such pointers will be performed on full pointer size (i.e. page
  number and offset) instead of just the offset portion.
- New compiler message (C12003) to report illegal use of the __far24 pointer qualifier, which is
  only valid in the context of data pointer types - it cannot be used with data objects, functions or
  function pointers.
  C12003: Illegal qualifier: __far24 can only be used with data pointers
- New compiler options to specify default values for the page registers:
    - DefaultEpage : defines the default value of the EPAGE register
    - DefaultPpage : defines the default value of the PPAGE register
    - DefaultRpage : defines the default value of the RPAGE register.

List of fixed Bugs
- None.

List of Limitations
- The S12X compiler optimizes pointer accesses based on some data distribution scenarios and the assumptions
  that:
  a) pointers declared as pointers to constant data do access constant data;
  b) pointers declared as pointers to non-constant data do access non-constant data.
  Breaking these assumptions will result in loss of data at pointer access.
  Example 1:
  struct S {
    int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  The snippet exhibits an access to non-constant data ('a') through a pointer to constant data ('p').
  This will lead to loss of data when pointer accesses are optimized with -ConstQualiNear. Fortunately,
  the compiler warns against the possible loss of data with the following message:
  Warning : C1825: Indirection to different types ('int *const ' instead of 'const int *const ')
  Example 2:
  struct S {
    const int a;
    char b;
  }s1;
  void foo() {
    const int * p = &s1.a;
  }
  This is yet another example of an access to non-constant data through a pointer to constant data:
  although member 'a' has been declared as 'const', the s1 data structure instance is non-'const' and,
  therefore, will not be placed into ROM. The compiler will warn against 'a' being a 'const' member of
  a non-'const' structure instance, because accessing 'a' via a pointer to constant data (likely to occur)
  will cause loss of data when pointer accesses are optimized with -ConstQualiNear.
  Warning C12001: 'a' is a const member of non-const instance 's1' of structure 'S' (possible loss of
  data at access to non-constant data through pointer to constant data, when pointer optimization is
  enabled via -ConstQualiNear).
- Suppose that pointer accesses are being optimized with -NonConstQualiNear. If a function expects a
  parameter which was declared as a pointer to another pointer type, dereferenciation, within the function,
  of the inner pointer will lead to loss of data.
  Example 1:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar(int * p) {
    foo(&p);
  }
  void main() {
    int x;
    bar(&x);
  }
  Workaround: modify the declaration of parameter 'p' so as to suppress undesired optimization in the callee:
  void foo(int * far * p) {
  ...
  }
  Example 2:
  void foo(int * * p) {
    **p = 1; // the pointed-to 'int *' type will be treated as a near pointer type because of -NonConstQualiNear
  }
  void bar() {
    int x;
    int * px = &x;
    foo(&px);
  }
  Workaround: modify the declaration of variable 'px' so as to suppress undesired optimization in the caller
  (here, optimization is performed earlier than in Example 1 - upon the pointer access to 'x' via 'px').
- The compiler does not currently support near-to-far or far-to-near conversions upon initialization of a global
  or static variable. This means that the use of –NonConstQualiNear or –ConstQualiNear should be avoided on code
  on which it results in such conversions.
  Example:
  unsigned char testByte @ 0x1234 ;
  const unsigned char * byteAddrP0 = & testByte ;
  static int foo ( void ) {
    return byteAddrP0 == ( unsigned char * ) 0x1234;
  }
  Given this snippet of code, let us suppose we choose to optimize pointer accesses via –NonConstQualiNear.
  Global variable byteAddrP0 was declared as a pointer to constant data, while variable testByte is a non-const
  global variable of type ‘unsigned char’. Using –NonConstQualiNear will, therefore, lead to a near-to-far
  conversion upon initialization of variable byteAddrP0. The compiler will generate a warning:
  Warning : C1825: Indirection to different types ('unsigned char *const near ' instead of 'const unsigned char *const far ')
  However, it will not handle the conversion – which is why function foo will return 0, instead of the
  expected 1. The fact that variable testByte is an absolute variable does not change, in any way, the behavior.
  It only serves illustration purposes.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.37
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.

List of fixed Bugs
- MTWX31238, "If" condition is not executed correctly when low-level Common Subexpression Elimination is enabled

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.36
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.

List of fixed Bugs
- MTWX29067, incorrect code generated for the initialization of 32-bit variable.
- MTWX28965, incorrect pointer arithmetics when the pointers are members of a structure.
- MTWX28810, fatal error issued when overloading virtual methods in a derived class.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- MTWX30444, the compiler may crash after issuing "FATAL C5650: Too many locations, try to spilt up function".
  This problem can occur for very large functions.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.
- When overloading virtual methods in a derived class the compiler might issue a fatal error.
  Example:
  struct S1 {
    int j;
    virtual void f(int){}
  };

  struct S2 : S1{
    virtual void f(S1 &) {}
    virtual void f(int) {}

    void g(int i) { f(i); }
  };

RELEASE NOTES CHC12 V5.0.35
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.

List of fixed Bugs
- MTWX26300, incorrect register used when assigning the result of a shift instruction to a local variable.
- MTWX26409, internal error #394 when source code contains a macrodefinition referring to an undefined global variable.
- MTWX27164, internal error #604 in 'hiware\src\ccpp\ccpp.cpp' when compiling the following assignment:
  S32_res = S32_res + ((signed long) S16_val1 * S16_val2);
- MTWX20780, incomplete error message generated when customer attempts to use option -CpPPAGE=RUNTIME for HCS12X or HCS12XE.
- MTWX27832, useless warning issued when a member of a bitfield is set to 0 (occurs when the
  size of the member is 8 bits). Example:
  typedef struct _field {
    unsigned int f1 : 8;
    unsigned int f2 : 8;
  } field_T;

  field_T f;

  void foo(void) {
    f.f2 =0x0;
  } ------^------ WARNING C5900: Result is zero

- MTWX20872, the compiler fails to report error on initializing local objects of aggregate type
  with non-constant expressions.
- MTWX19620, the compiler handles char array objects which have been declared as 'const' depending
  on the syntax used for initializing the array (works as expected only if the array has been
  initialized using braces-based syntax).

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.

RELEASE NOTES CHC12 V5.0.34
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources

List of new Features
- None.

List of fixed Bugs
- MTWX26380, the unsigned long division routine may lock up during division. For instance
  for the following input 0xFFFFFFFF/0x0001B304 the routine goes to an infinite loop.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.

RELEASE NOTES CHC12 V5.0.33 build 7253
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources


List of new Features
- Compiler issues message "WARNING C1805: Non standard conversion used." when it does not perform address conversion at initialization of constant pointers. (MTWX21086)

List of fixed Bugs
- MTWX26048, Assertion "Internal Error #1208 in 'F:\build\Products\Hiware\cw_hc12_v45_b020706\hiware\src\compiler\Back\Icg\Gloc.c'.
- MTWX25578, Use of #pragma TRAP_PROC SAVE_ALL_REGISTERS generated store/restore of uncorrect address location.
- MTWX24391, In some conditions the ternar operator is not compiled correctly when used with bitfields.
- MTWX24390, Incorrect code generated due to problem in tree optimization.
- MTWX24257, Problem allocating memory when heap is placed in paged memory (HCS12X, HCS12XE only).
- MTWX24043, Multiplication involving signed long operand does not generate the call to the signed long 16x32 bit MULtiplication routine, but to the unsigned version.
- MTWX23213, Compiler should not repeat full path of header files several times in .debug_line .
- MTWX25778, ldexpf()gives an incorrect result when called with ldexpf(0.0, -2); .
- MTWX25915, Internal Error #573 appears when trying to compile pointer arithmetic on function identifier.
- MTWX24649, Never ending loop generated under some conditions.
- MTWX24047, Internal Error when function pointer gets initialised to a ram page address.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.



RELEASE NOTES CHC12 V5.0.33
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources


List of new Features
- Floating license lingering time has been reduced from 10 minutes to 5 minutes to make floating licenses faster available for another user.
  Note that the floating license server administrator can extend the lingering time using a configuration file (see Macrovision FLEXlm documentation for details).

List of fixed Bugs
- MTWX22602, do not save anymore non existing MER in interrupt handler entry code. e.g. DPAGE will only be saved for HC12.
- MTWX23726, for -Cp<MER>=<value> option let MER register defaults be derivative dependent. e.g. for CPU12 PPAGE is at 0x35 and for S12 it is at 0x30.
- MTWX23303, Incorrect result when doing 16bit*16bit signed long multiplication, and result is stored in a local variable through a += operation.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.



RELEASE NOTES CHC12 V5.0.32
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources


List of new Features

List of fixed Bugs
- MTWX22438, incorrect address conversion for EEPROM Page in library function _CONV_NEAR_TO_GLOBAL
- MTWX22341, incorrect address calculation when casting a 2 * unsigned int struct to an unsigned int buffer[]
- MTWX21166: incorrect code generated by LEA/LEA peephole (bad fixup).
- strcmp/memcmp/strncmp must compare the first non matching character as unsigned char
- In case there was no license available from the server, -LicWait did not had an impact

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.

RELEASE NOTES CHC12 V5.0.31
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources


List of new Features

List of fixed Bugs
- MTWX20872: issue an error for non constant initializers. the previous versions generated wrong initialization code (they took the address)
- MTWX20912: printf argument list mismatch: 2 strings missing. fixed possible crash by adding them.
- MTWX20673: HLI crasher if more than 2 parentheses are used within constant expression
- MTWX20979: compiler assumed only 8 bit arithmetic on relocation for array access (but linker does 16 bit arithmetics).
             happens only if result of access is casted to int.
             Example: int i; ... *(int*)&array[i - 0xECC]  was wrongly optimized to *(int*)&array[(char)i - 0xCC]


List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.


RELEASE NOTES CHC12 V5.0.30
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources


List of new Features
- MTWX20210: new compiler option -CVolWordAcc
             if switched on, the compiler does not anymore reduce the size of volatile op-assigns (e.g. volatile int x; x |= 64;)

List of fixed Bugs
- MTWX20659: conflict between 2 spill locations used by register variables. the same spill location was shared among different values. happens only with option -or.
- MTWX20634: when the license file is accessed using the path from the LM_LICENSE_FILE environment variable (i.e. there is no license.dat in the
  tool's directory or its parent, nor is there a hiware.dat license file), and a required feature expires in less than 10 days, a crash occurs.
  This bug is fixed for build numbers greater than 6088.
- MTWX20506: compiler aborted after error state (limitation). now it only displays the error message.
- MTWX20194: crash after trying to instantiate template argument with a constant. happened only if argument was instantiated multiple times
- MTWX20179: wrong array access on small array with negative 32 bit index and non zero offset, eg. long index = -4; arr[index+4]
- MTWX20118: cut optimization for shift operations is working when the result is 16 bit-wide too.
- MTWX19954: wrong internal error after optimizing a switch statement with a compile time computed switch selector.
- MTWX19853: wrong debug information for local variable allocated in interrupt routine, if page registers are saved.
             debugger shows local variable 1 byte shifted.
- MTWX19733: internal error when compiling #define TEST(x,y) x#y ... TEST(abc,) in some context. Now an error is issued instead.
- MTWX19426: internal error while compiling a ? operation with unary + operator on indirect memory.
             Example: * ptr < 0 ? - * ptr: + * ptr.
             the internal error happens only with option -cni
- MTWX19411: wrong absolute branch target printed out in assembly listing output file (option -lasm).
             Happens with relative branches between 127 and 129.
- in checksum.h, all available checks were enabled by default.
  This resulted in a slow and non configurable setup. Now only a single checksum is computed by default,
  and this setting can be overruled with defines without modifying checksum.h.
  To restore the previous behavior, define _CHECKSUM_CHECKSUMS_ when compiling checksum.c and start12.c,
  for example by adding -D_CHECKSUM_CHECKSUMS_ to the compiler command line.


List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- #MTWX20194, C++, nested template classes not compilable.
  Example:
  class A {
    ...
    template <int i> class B {
    ...
    };
  };
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.



RELEASE NOTES CHC12 V5.0.29
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources


List of new Features

List of fixed Bugs
- Opening files from the builtin Windows GUI with double clicking did cause a crash
  if the File->Configuration->Editor Settings dialog was configured as "CodeWarrior (with COM)" and if an old IDE 4.1 was
  configured as current CodeWarrior IDE to be used. It did work as expected with if any
  more recent CodeWarrior IDE was registered.
- MTWX18969: double write to a volatile structure. The value is assigned twice.
             Example: SCI1BDH_U.Byte = (unsigned char)((BaudWert >> 8) & 0x001F);
             The structure field SCI1BDH_U.Byte was assigned twice with the right hand side.
- MTWX18239: Internal error for 24 bit to 24 bit pointer conversion in singular context. HCS12X only.
- MTWX18234: Compiler irregularly generated a signed 16 * 16 to 32 bit multiplication (EMULS) instead of an unsigned one (EMUL).
             Happens only in very singular cases.
- MTWX18197: The optimization that converts (a * b) << 8 into a * (b << 8) took a instead of b
             if both a and b zero extended, but b is a 8 bit character and a is a 16 bit integer.
             Workaround: swap a and b so that the expression is (b * a) << 8 or
             switch off the optimization using -ont=m
- MTWX18038: internal error while compiling a loop containing array accesses with similar indexes. same as MTWX14487
- MTWX17885: Compiler did not calculate the right index for a table for accesses of the form:
             arr[index + const] when index has byte size and const is negative and the size of
             the array is less than 256 bytes. The negative offset has been converted to a unsigned byte value.
- MTWX17811: wrong branch chaining over multiple (>2) branches (options: HCS12X and -ont)
             in singular case. happened after fixing MTWX17157 for different code pattern.
- MTWX17724: HCS12X wrong B,X array access optimization when paged and non paged arrays
             are accessed with same index. The bug only happens if they are more or equal 2 accesses
             on the non paged array.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.


RELEASE NOTES CHC12 V5.0.28
Note: These Release Notes contain some information about the C++ Compiler. If your
license configuration does not include the C++ feature, just ignore all topics related to C++.
NOTE: Recompile all your sources


List of new Features
- #pragma align on : switch on same alignment as used by XGATE compiler. used to share data between HCS12X and XGATE cores.
- #pragma align off : switch back to no alignment as used by HC12 compiler.

List of fixed Bugs
- MTWX17364/MTWX9477: icg cse did incorrectly reuse Array[var+const] or Array[const+var] to implement another access of the form Array[const-var].
             The negative sign of the var variable was not taken into account.
- MTWX17205: compiler crash (internal error) for multiple char indexed array accesses (special pattern).
             bug only happens with option -ont. Workaround: switch off -ont or use int or short indexes.
- MTWX17203: compiler crash (internal error) for a non ANSI-C conforming program calling a parametrized macro without parameters.
             The compiler displayed an error just before the crash.
- MTWX17192: compiler crash (internal error) for or-assign to bitfield with a not constant value as shift count.
             Bug example:  bf.field |= (1<<bitno);   (bitno not constant). Reported using HCS12X.
- MTWX17158: wrong pointer conversion from far to near on accesses to array of bitfields. The fixed compiler
             will not show the warning "possible loss of data" and will generated correct code (i.e. far access)
             Reported using HCS12X.
- MTWX17157: fixed branch chaining bug that happened in a nested if block. Reported using HCS12X.
- MTWX17160: improved wording in derivative header files (comment).
- MTWX16711, addressing mode B,X optimization was wrongly applied to index assigned to register (option -or).
  The optimization is disabled for register index (option -or) for now.
- MTWX16716, missing treatment of byte accesses on 16 bit spills.
  This bug happened only if spills of 8 bit values have been merged with spills of zero extended values.
- fixed handling of C++ static members and variables declared extern inside of function scope in the large memory model. Previously the default large access type was not used.
- MTWX20131, the speed optimized version of start12.c (when compiled with -ot) did not work correctly when only one byte had to be initialized.

List of known Bugs
Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.



RELEASE NOTES CHC12 V5.0.27
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources


List of new Features
- global initializations with constant address differences between the same object are now possible.
  Example:
  struct {
    int a,b,c;
  } s;
  int diff = (char *)&s.c - (char *)&s.a;
- using the option -Oc does now cause the message "C54: Option -Oc: depreciated". This option is also no longer displayed in the
  graphical user interface.
  With previous compilers, using -oc was silently ignored.
  Note: There are other option to control the actually done common subexpression elimination.

List of fixed Bugs
- Preprocessor conditions are now evaluated with long arithmetic.
  The previous compiler did use the same arithmetic when evaluating preprocessor conditions
  as when evaluating constant conditions in C code.
  However ANSI C 89 mandates that for preprocessor conditions (#if's)
  the int representation should be enhanced to the representation one of long.
  Example (assuming int is 16 bit):

  #if 30000 + 30000 + 30000 == 90000 // TRUE
  #endif
  void test(void) {
    if (30000 + 30000 + 30000 == 90000) { // FALSE
    }
  }

  Explanation.
  For ANSI C, the result of a int + int operation has the type int.
  Therefore the type of "30000 + 30000 + 30000" is int.
  If int is 16 bits the additions do overflow and the condition evaluates to FALSE.
  However while evaluating the expression for the preprocessor, int is extended to 32 bits.
  Therefore the additions do no longer overflow and the expression in the #if evaluates to TRUE.
- MTWX16009 reduce complexity from exponential to linear time. It only happened for empty switch statements with a certain number of case labels.
  The compilation time was O(2 ^ nof_labels). Now it is O(nof_labels).
- MTWX8079: BSR *<num> (e.g. BSR *70) is now accepted by the inline assembler
- MTWX16741: wrong code generated for indexed array access (workaround was to use -onp=x, this option is no longer necessary)
  For the following code, the compiler generated a "STAA A,X" for the last assignment (now the correct "STAA  B,X" is generated).
   unsigned char Test5_arr1[64];
   unsigned char Test5_arr2[8];
   char Test5_a,Test5_b;
   void Test5_f(unsigned char val, unsigned char *cptr, unsigned char j) {
     *cptr = j;
     Test5_a = Test5_arr2[val & 0x07];
    Test5_b = Test5_arr2[val >> 3];
    Test5_arr1[val] = j;
   }


List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.



RELEASE NOTES CHC12 V5.0.26
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources

COMPATIBILITY Note (Details below in "List of new Features"):
- projects for previous HC12 (V3.0, V3.1) versions which do use far data and
  more specifically far struct copies do need the new datapage.c.
- Code generated for the HCS12X does use a different kind of far data pointer than code for the HCS12.
  The code generation for this version is compatible with old version as long as just HCS12 code is generated.
  However with the option -CpuHCS12X, the far pointer handling code is different.
- Bitfield handling of bitfields larger than one byte in the HC12 V3.0 was unintentionally different than the one from V2.0 or for V3.1.
  This version keeps the compatibility with V2.0 or V3.1 but does therefore break it with HC12 V3.0.
- The ANSI library of HC12 V2.0 or before did contain derivative specific code which was compiled for a HC12 A4. Since the CW Version V3.0,
  these source files are no longer part of the ANSI library. For details, see the text for the compiler version CHC12 V5.0.24 below.
- as this compiler does support the new HCS12X instructions, these mnemonics are no longer supported as HLI labels.
   E.g. "__asm incy: INY;"
  This example will no longer compile as "INCY" is one of the new HCS12X instructions.
  Note: the rtshc12.c delivered with previous compilers did contain a label named "decy" in _LDEC.
        In order to build it with this compiler, rename the label to something else, for example incy_.

List of new Features
- MTWX14650: cycle counts are now reported in the listing file (option -Lasm) as well. You can switch this off using -Lasmc=y.
- Lingering time for floating licenses has been extended to 10 minutes, to allow caching of licenses (to reduce compilation time)
- Moved the macro CLOCKS_PER_SEC from hidef.h into time.h
- Mapping unknown messages is now treated as warning and no longer as error. This change allows to maintain compatibility with old build tools when removing no longer used messages.
- Message C2402, "Variable <varname> allocated in ROM" or "Variable <varname> allocated 'far'" is now disabled by default.
  The message can still be explicitly enabled.
- new option -LpCfg=m to suppress information about file names in preprocessing output file (option -Lp)
- new option -LpCfg=e to allow empty lines in preprocessing output file (option -Lp)

List of fixed Bugs
- The incorrect method _LABS was removed from rtshc12.c. This method was not used at all.
- MTWX15771 & MTWX15767: avoid wrong floating point conversion optimization: -(double)(int) ->(double)-(int) opti
- MTWX14487: Fixed internal error happening with the options -ont and -oi in singular cases.
- MTWX15441: Internal overflow with many include files fixed.
  This overflow did cause wrong debug (line) information or could also cause crashes.
  In addition increased the limitation to 512 concurrent include files.
- MTWX15376, far calling convention was used for ((void (*__near)(void))&func)(); if banked or large memory
  model is used. Previous versions did not have this bug because they did not optimize the *&. V5.0.26 will
  still optimize *&, but respect pointer type conversions.
- Fixed: preprocessor bug. macros which do expand to a function style macro with the braces not being part of expanded part of the initial macro are now correctly handled.
- V5.0.25 contained in HCS12X V4.0 does generate wrong debug info for HC12 far pointers.
  This does cause that global initialization does not work in the large memory model for the HC12 (it does work for the HCS12X).
  Note: the debug info for HCS12X is correct and officially HCS12X V4.0 is for HCS12X only.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.

Demo Version Limitations
If you do have a demo version of the compiler, there are following limitations:
- Total code size for a source file (compilation unit) is limited to 1024 bytes



RELEASE NOTES CHC12 V5.0.25
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources

COMPATIBILITY Note (Details below in "List of new Features"):
- projects for previous HC12 (V3.0, V3.1) versions which do use far data and
  more specifically far struct copies do need the new datapage.c.
- Code generated for the HCS12X does use a different kind of far data pointer than code for the HCS12.
  The code generation for this version is compatible with old version as long as just HCS12 code is generated.
  However with the option -CpuHCS12X, the far pointer handling code is different.
- Bitfield handling of bitfields larger than one byte in the HC12 V3.0 was unintentionally different than the one from V2.0 or for V3.1.
  This version keeps the compatibility with V2.0 or V3.1 but does therefore break it with HC12 V3.0.
- The ANSI library of HC12 V2.0 or before did contain derivative specific code which was compiled for a HC12 A4. Since the CW Version V3.0,
  these source files are no longer part of the ANSI library. For details, see the text for the compiler version CHC12 V5.0.24 below.
- as this compiler does support the new HCS12X instructions, these mnemonics are no longer supported as HLI labels.
   E.g. "__asm incy: INY;"
  This example will no longer compile as "INCY" is one of the new HCS12X instructions.
  Note: the rtshc12.c delivered with previous compilers did contain a label named "decy" in _LDEC.
        In order to build it with this compiler, rename the label to something else, for example incy_.

List of new Features
- 1-54681434: New option -LicWait. If set and used with floating license configuration, if no license is available from the license server,
  it will wait until a license is available. This is useful if you want to wait until a license is free, e.g. with batch jobs.
- _FAR_COPY is replaced by _FAR_COPY_RC. This runtime routine is responsible for struct copies from or to banked data.
  The new _FAR_COPY_RC does now pass the size of the structure to be copied just at the return address.
  The old version did pass this size as additional argument on the stack.
  E.g.
   ..
   JSR _FAR_COPY_RC
   DC.W sizeof(struct)
  This change does generate denser code than before.
  Note: _FAR_COPY is handling with far pointers, which means it's derivative dependent. Therefore _FAR_COPY is encoded in datapage.c
  which is usually part of the user application source code. Therefore projects using far data will not link with a missing _FAR_COPY_RC
  as long as the old datapage.c is part of the project. If this happens, either take and adapt the new datapage.c (in the directory lib\hc12c\src)
  or copy the definition of _FAR_COPY_RC into your version.
- Fixed: only numbers starting with a digit were accepted for hex notation (e.g. $1234) in
  inline assembly. Now the full range of hexadecimal numbers are accepted. See compiler manual for details.
- Support for binary numbers (e.g. 0b100101). See compiler manual for details.
- The messages C1800 and C1801 (missing prototype) show now the function name causing the message too
- The about box (and option -Lic) shows now as well borrowing status (same as lmborrow.exe -status)
- New option -LicBorrow:
  -LicBorrow    Borrow license feature (-LicBorrow<feature>:<Date>, <Date> in dd-mmm-yyyy[:hh:mm] format and
  time in 24-hour hh:mm format)
  It enables selective borrowing of features (supported by the application). Note that borrowing is only supported
  if enabled in the license file by the BORROW keyword.
- In case of an expire/evaluation license, you are now warned 10 days before the license expires.
  The warning dialog box pops up once every day.
- The check for demo or license limitation on code size happens now at the end of the compilation unit.
  In case you are running into such a limitation, this provides better feedback and an indication
  what kind of upgrade license would be required.
- FLEXlm support for BORROWING. Note that BORROWING is only available for floating licenses, and may be sold
  as a separate product or for an additional fee. BORROWING is used so you can work with a floating license
  even if you are disconnected from the licensing server. See FLEXlm user manuals for details on BORROWING.
  Note that this product needs a FLEXlm daemon (metrowks.exe on the licensing server) with following
  version information:
  FLEXlm v8.4a (lmgr.lib), Copyright (c) 1988-2003 by Macrovision Corporation. All rights reserved.
  The latest FLEXlm floating server software can as well be downloaded from the www.metrowerks.com
  web page, or get in touch with support to get the latest version.
- Extended CodeWarrior IDE coloring files (located in bin\editor). The coloring supports now additional
  predefined macros defined by the compiler. You can get such a list of predefined defines using the compiler
  option -Ldf.
- Support for the HCS12X Core (enabled with option -CpuHCS12X):
   - the new instructions are used to generate denser and faster code than before. Especially 32 bit arithmetic code is improved.
   - with -CpuHCS12X, __far pointers are accessed with the new GPAGE load and store instructions. Note that this implies a complete
     new address layout used for far pointers.

List of fixed Bugs since HCS12X V4.0 rc
- fixed bug in S122X DP512 prm file: ram area RAM_FB was not used, RAM_FD was listed twice instead.

List of fixed Bugs
- MTWX11777: compiler reused an equivalent operand that has been killed by an alias in between.
- MTWX12861: Backend error for code with option -Ti4 (int is 32 bit)
- MTWX13136, MTWX16923: wrong address calculation for arrays of size > 127 bytes and < 256 bytes, if the index is a signed integer. The sign extension
  is now replaced by a zero extension.
- MTWX12845: internal error when 24 bit function address is casted to void * and extended to long
  Example: (long)(void *)&my_far_function
- 1-53814465: in case of ClearCase version control plugin, and if the local settings for decimal point were not '.', license checkout
  was not working in all cases.
- for -LpCfg=s: preprocessor output, reconstruct spaces. User code using interrupt is emitted with the equivalent but longer __interrupt.
  However this length difference was not taken into account causing non compilable code.
- MTWX11843: treeopt bug for patterns "a -= b; a++;" and "a++; a-= b;". Treeopt generated "a -= b + 1;" instead of "a -= b - 1;"
- bug in HCS12X alpha release: startup code compiled with -ot did not correctly zero out the last variable byte.
- MTWX10702. When using the -Or compiler option, the wrong offset is used for a local variable. The reason
  was that another equivalent local variable was accessed to save spill code, but the equivalence was not given for
  all paths in the control flow.
- sscanf did not exactly follow the ANSI standard about returning EOF for input failures if no conversions where done.
  It did return EOF also for some conversion failures if no conversions where done.
  %n was also not considered as conversion in this respect.
- MTWX10491, wrong address calculation for pattern
  char array[100];
  ...
  (int) (*(int *)((&array[idx] ) + 2))
  The cast to int*, the index 'idx' and the offset '2' are necessary to get this bug
- 50835907: Error message "C12110: Out of spill locations: Reduce ? - expression" caused by (implicit) -ol2.
  Now more (up the host memory amount) spill locations are possible. Message C12110 is removed.
- WB1-51395: constants were replaces although option -OnCstVar was specified
- avoid crash for (more than) 4092 open #if without any #endif. New behavior is to issue
    C4449: Exceeded preprocessor #if level of 4092
- 1-49728412/1-49949006: Inlining bug:
  with inlining enabled (-oi=c10) code like
  if (x && fun()) { X; } else { Y; }
  did not execute Y in some cases (even if fun was not inlined)
- WB1-50584, HEX number was not recognized in macros. This wrong behavior gave an unexpected error message
  for HLI code like "asm bclr $38,#$80;" used in a macro.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs :
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.


RELEASE NOTES CHC12 V5.0.24
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources
  Note: CHC12 V5.0.24 contained in CW for HC12 V3.1 does require a license version of at least 3.1.

List of new Features
- printf and scanf do no longer support the FAR data pointer qualifiers. With this change, datapage.c is only needed in the
  small or banked memory model if some user code does explicitly use far pointers or does declare
  some variables to be allocated far.

- to change this behavior to the old support, define LIBDEF_PRINTF_FAR_PTR
   in libdefs.h and rebuild scanf.c and printf.c
  The simplest was to do this is to add -DLIBDEF_PRINTF_FAR_PTR to the compiler command line and to add lib\hc12c\src\scanf.c and
  lib\hc12printf.c to your project. More advanced users can also rebuild the library
  with the project lib\hc12c\hc12_lib.mcp (or a copy of it)

  For printf (and sprintf, ...) the following non ANSI qualifiers are no longer supported by default:
    %N: use a int*far to return the number of bytes read
    %S: use a const char* far to print a string
    %P: print a far pointer as number
  Note: The most useful %N qualifier was not correctly supported in previous versions.

  For scanf (and sscanf,...) the following non ANSI qualifiers are no longer supported by default:
    %P: scan in  a far pointer
    %S: scan in a string and store it via far pointer
    %N: return the bytes read via far pointer

    %+i: + modifier. Causes any format to use a far pointer instead.
  For scanf these modifiers are rarely used as they only help in situations where the ram has to be accessed far,
  which is less common than far rom.

List of fixed Bugs
- MTWX9634: for CHC12 V5.0.23 (for CW HC12 V3.0) , the default value for -BfaGapLimitBitsBit was changed from 3 to 0.
   Unfortunately this change did also cause that 16 single bit bitfields were now allocated as one single 16 bit field while
   while previous compiler versions did allocate them as two times a 8 bit bitfield.
   E.g.
   struct A {
     int i0:1;
     int i1:1;
     int i2:1;
     int i3:1;
     int i4:1;
     int i5:1;
     int i6:1;
     int i7:1;
     int i8:1;
     int i9:1;
     int i10:1;
     int i11:1;
     int i12:1;
     int i13:1;
     int i14:1;
     int i15:1;
   } a;
   For HC12 V3.0, the bitfield i0 is the lowest bit of a 16 bit a value. As the HC12 is bigendian,
   this turns out to be at the byte-offset 1 of a. i15 on the other hand is allocated by HC12 V3.0 at byte-offset 0
   with mask 0x80.
   For HC12 V2.0, the bitfield i0 is the lowest bit of the first byte of the a value. Therefore it has mask 1 and byte-offset 0.
   i15 on the other hand is allocated by HC12 V2.0 with mask 0x80 at byte-offset 1.

   HC12 V3.1 is by default again compatible to HC12 V2.0 (and NOT to HC12 V3.0).
   The write code which is compatible with all HC12 compilers, the recommended workaround is
   to set the option -BfaGapLimitBitsBit1 for HC12 V3.0.
   This can be done in the source code with the following pattern:

      #if defined(__HIWARE__) && defined(__HC12__) && defined(__VERSION__)
      #if __VERSION__ == 5023 && !__OPTION_ACTIVE__("-BfaGapLimitBits")
      #pragma OPTION ADD "-BfaGapLimitBits1"
      #endif /* VERSION */
      #endif /* __HIWARE__ */

   Note: this workaround is only necessary if:
    - You do have 16 bit bitfields. for 8 bit bitfields, the compilers are generating compatible code.
    - You do need a certain mapping of the bits. All compilers do behave ANSI compliant. This bug is that the V2.0 and the V3.0 do not
      behave identical.
    - The option -BfaGapLimitBits is not specified. With the option "-BfaGapLimitBits1" all compilers do allocate the bitfields identical.

- the %N qualifier for printf did not correctly work in the small or banked memory model. Instead a far pointer was received
    and immediately assigned to a near pointer, loosing the page information before the access happened.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.



RELEASE NOTES CHC12 V5.0.23
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources

List of new Features
- Change default value for option -BfaGapLimitBits to 0 (was 3 bits).
  To prevent wrong I/O register accesses, the compiler will no longer insert extra gaps into bit field structure (he did it for optimization)
  by default. This change is related to WB1-49951.
- Cosmic compatibility mode (option -ccx):
  The compiler now accepts the Cosmic style space modifiers @near, @far and @tiny and emulates the same
  semantics as the Cosmic compiler, i.e. objects are allocated into special _CX_xxxxx sections that can
  be mapped to appropriately into zeropage RAM, near or banked ROM or RAM. See the compiler manual for
  more details. See also TN 234 for other important aspects of porting applications from Cosmic to
  CodeWarrior (calling convention, Assembler, etc)
- IMPORTANT: Derivative specific object files were removed from the ANSI library.
  With previous versions, some derivative specific code was included in the prebuilt ANSI libraries.
  If you have an existing library using this code, it will no longer link with the current version.
  This change included the following files:
    - datapage.c: Datapaging. The previous library did contain prebuilt versions of functions like
        _STORE_FAR_16 or _LOAD_FAR_16, which were built for a HC12 A4. In order to rebuild your
        application with this version add datapage.c to your project and define some macros appropriately.
        For all HCS12's for example add "-D_HCS12" to the compiler command line. For additional details,
        read in "lib\hc12c\src\datapage.c".
    - termio.c:
        Termio.c does contain a very simple implementation to use the HC12 SCI.
        However since different HC12's (and HCS12's) have the
        SCI ports at different addresses, this did work only for some
        derivatives (it was initially written for a HC12A4).
        To avoid the situation to have a library with fixed code for another derivative,
        the object code of termio.c code was removed from the prebuilt library.
        If you would like to use the termio.c code, just add lib\hc12c\src\termio.c
        to your project in addition to the ANSI library.
        The termio functions are used by the default printf implementation.
    - codepage.c:
        This file did implement some special custom code banking.
        Its code is not used by the compiler by default.

  Note: These changes may need adaptations of projects generated with previous versions.

- New option -lpcfg for preprocessor output in #line format. This is useful e.g for instrumenters to get
  the source file and -line easily.
- the derivative headerfile and sourcefile have been renamed, the old files are still provided but generate a warning when used.
- WB1-45472: issue a message 'lost of data' as well for unsigned char like 'uc = 0x1234;'.
- The startup code start12.c now contains a speed optimized version
  when compiled with -Ot.
  Setup (small memory model, unmodified startup code, no wait states)
  char d0[50];            // init 50 bytes with zero.
  char d1[50]="ab....";    // init 50 additional bytes with non zero value
  - non optimized (same as previous startup code): 963 cycles
- new pragma LINK_INFO to pass information into the ELF file to the linker.
- The macro '__MWERKS__' is now defined with the value 1 by default in the
  compiler: #define __MWERKS__ 1
- The ANSI library no longer contains the software floating point module softfloa.c.
  The src code however is still include, so you can still build it if necessary.
  However the native floating point support is much faster and softfloat should only
  be used with care (about the code size and the execution speed).
  Removing it from the library also decreases the time to build the library.
  Note: This change may eventually need adaptations of user projects.
- the stl header files are no longer delivered as they are not part of EC++.
- the S12_Projects previously in lib\hc12c\S12_Projects are now part of the Stationery folder and can be directly
  used with the IDE's File->New dialog.

List of fixed Bugs
- WB1-49806, register was irregularly overwritten by a spill while passing parameters with common values (CSE)
- WB1-49138, C++ name mangling for nested classes not unique because length of classname was not encoded.
- SR1-48365391, wrong error message C1019 for implementation of a static member. This bug only happened
  if many static members are declared (hash list problem)
- WB1-47966, Wrong 'switch' table generated if no code in 'case' statement:
  It can happen for the following constellation for (;;) { ... switch (...) { ... case Label: break; ... } }
  1. some loop around a switch
  2. no code before the switch in the loop.
  3. no code after the switch before the loop ends.
  4. an empty switch entry.
  5. a constant loop condition.
  6. a case Label with no code afterwards (either with a break or at the end of the switch)
  The suggested workaround was to put some code before or after the switch.
- The #asm directive did have to be consistently balanced with #endasm with respect to #if 0/#endif's.
    #asm's in "#if 0" areas did have to balance as well.
    For example, the following code did not compile with an missing #endif error message
    #if 0
      #asm
    #endif
    The new behavior does no longer require that #asm's in not processed areas are terminated with a #endasm.
    However, processed #asm's do still need an #endasm on the same level.
    The previous code does now compile while the following code will still issue an error.

    #if 1
      #asm // error, no #endasm before the endif. #endasm's outside the surrounding or inside of another
           // #if #endif pair are not supported.
    #endif

    #endasm

- SR1-37884801, wrong name encoding in singular cases
  for functions with multiple arguments with same type. The application could not
  be linked in the error case.
- WB1-xxxxx, wrong long division for c = a/b; a = 0x0801F1A6, b = 0x00020082
- WB1-45272, wrong CSE of a array index, if array has been overwriten in between.
  Error situation:
  s.array[i] = j
  s.array2[ j] = i;
- The ANSI library function strtoul did incorrectly handle the "0" string for the automatic base detection case.
  As this function is used by sscanf and strtol these function did behave incorrectly as well.
  E.g.
  >char *endptr;
  >unsigned long res= strtoul("0", &endptr, 0);
  Did result in  endptr pointing to "0" instead of the 0 byte afterwards.
- WB1-43181  missing error message on attempt to init a static member in constructor
- WB1-43148, missing error message on pointer assignment with same struct name as
  base type, but different owner classes:
  class XXX {
     public:
       struct S {
         int a;
         float b;
       };
    };
    class YYY {
     public:
       struct S {
         float c;
       };
    };
    void main() {
      const XXX::S xs = {1, 2.0 };
      const YYY::S ys = { 3.0 };
      const XXX::S *p_xs = &ys;   // missing error message here
    }
  - WB1-43151,  overloading rules were not considered before checking access to
    protected member:

  class X {
      public:
         static void f(int b, int c) {}
      protected:
        static void f(int a, int b, int c) {}
    };
    void main() {
      X x;

      x.f(1, 2);   // worked
      X::f(1, 2);  // did not work, because the compiler tried to call the 2nd member
    }
- At the line end, when a backslash was followed by a space before the line end, the
  compiler did still treat it as line continuation in some cases. The new compiler will no
  longer join the two lines. Note: According to ANSI C, escaping a space is not
  allowed.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
  Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting Help
  about such a topic opens an error window. The help topics will be extended in the next
  release.


RELEASE NOTES CHC12 V5.0.22
  Note: These Release Notes contain some information about the C++ Compiler. If your
    license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources

List of new Features
- Important: The HC12 addressing modes (B,X), (A,X), (D,X), (B,Y), (A,Y), (D,Y)
  are now used to access arrays with variable index if code quality improves, i.e. if code
  size or execution time is reduced depending optimize for time is switched on or off.
  Code patterns of applications may change significantly between compiler versions 21
  and 22!
- The stack size value of –Ll does not contain the return address space of called
  functions.
- This version uses a new FLEXlm daemon (the Metrowerks one). If you already have a
  license for the former version, you need to upgrade your license. Additionally be
  aware that in compliance with other Metrowerks tools the license (license.dat) file in
  the installation root (e.g. c:\metrowerks\license.dat, the installation script has created
  a shortcut to this file) is used. If such a license.dat exists, this file is used to check out
  the license. Only if this file does not exist, the one in C:\FLEXlm is used.
  - New preprocessor directive #warning. Same as #error, but instead resulting in an error
  message, this directive produces a warning message only. Additionally, the message
  generated by #error can now be moved to another message kind.
  - Binary constants are now supported when the option -Ansi is not set
  Example:   var = 0b0101011
- Inline assembler supports now the following syntax: #asm …….. #endasm in function
  body - See manual for details.
  Example :
  #asm
     nop
     nop
  #endasm
- Inline assembler supports  now the following syntax: asm ( One_instruction )
  Example: asm(nop) - See manual for details.
- Inline assembler supports strings - See manual for details
  Example: _asm("nop") or _asm(" nop; nop ; nop") or _asm "nop; nop"
- Following special macros are supported now in the environment too: {Compiler},
  {Project} and {System}. See manual for details.
  Note: Those macros are newly available during environment variable substitution.
  They are not automatically supported in filenames in general.
- Message C1069 is movable now (was error by default)
- New option -OnCstVar to switch OFF CONST variable by constant replacement. See
  manual/help file for details.
- R2652: It is possible now to change the color for messages in the tool window. It can
  be changed for WARNING, INFORMATION, ERROR, FATAL and for user
  messages as well. Following options are available for this: -WmsgCW, -WmsgCI, -
  WmsgCE, -WmsgCF and -WmsgCU. See manual for details.
- The compiler option –NoDebugInfo does now also support the HIWARE format.

List of fixed Bugs
- (unsigned short) x (unsigned short) operations (e.g. divisions) were incorrectly performed signed in V5.0.21.
  (Note: this entry was not in the initial V5.0.22 release note but later added)
- Rxxxx, wrong array index calculation for int arrays
  Example: int arr[200]; i = 128; arr[i] = my_var
  In this case arr[0] was accessed instead of arr[128] (bit 7 was shifted out)
- Rxxxx, register manager assumed the value 0 in register B at the beginning of a case statement
  list. The register B was overwritten during evaluation of the switch(<expr>).
- R2954, partial assignment to union did not kill the alias of the same memory location.
- When running as plug-in CodeWarrior, the generation of browse information did slow
  down the compilation considerably for large files containing many defines.
- SR 1-7L1JX, Ansi library function memcpy2 was wrong and copied one byte too
  much.
- R2891, wrong code for field accesses to structs returned in registers. In future, structs
  and unions will not be returned in registers to assure correct code in all cases (e.g.
  bitfields).
- 1-5MXNM & R2819: in case of illegal preprocessor token concatenation, the left
  token was ignored. Example:
     #define foo(_size)  int buf ## _size;
     foo([3])
  'buf[' is not a legal preprocessor token, so the compiler was ignoring the '[', because
  the behavior is undefined in the ANSI standard. However, to have a more
  consistent behavior, the above macro is now processed to 'buf[3]'.
- R2864: in case of  % operation with following compare routine, the compare was
  done on 8bit instead of 16bit. Workaround was to use -Ont
- R2832, generation of warning for implicit conversion from const X * to X *  in   C
- R2813: if counter variable was volatile and used in a switch statement like
  'switch(counter%4), then code was optimized away for switch case with 2 and 3.
  Workaround was to use –Ont=8 to disable the wrong optimization.
- R2806, HLI didn't accept CALL [ptr,PC]
- R2787, a crash occurs in initialization member (see below)
  Example
  Class A {
     Public:
     int i;
   A():i(){}
  }
- R2773: Wrong optimization for address bits 16 to 23 of a function address. Compiler
  assumed it would be the page, but for the HC12 it's the high byte of the address. The
  compiler did reuse the same high part for different objects in the same page.
- R2772: bug in optimization of % constant for unsigned types.
- R2766, ANSI library for IEEE32 returned a –0.0 instead 0.0.
- R2743, the compiler generated a wrong dependency list for constructors with default
  arguments.
- R2747, a crash occurs because the compiler was mistaken about the choice of the
  parameter or the class member when they have the same name
  Example :
  class A{
  public:
           A(int value);
  private:
           int value;
  };
  A::A(int value): value(value) {}
- R2729, R2781, R2804: fixed internal error in case of the option –Lasm with indirect
  PCR relative addressing mode.
- R2696: wrong syntax tree was generated for such Ctor call ClassName::ClassName :
  member(new memberType){}
- R2681, C++: avoid assertion in error case.
- R2682, C++: wrong type checking for template class as return value.
- R2665 wrong global initialization of a 32 bit large variable with 16 bit large function
  pointers.
- R2679 wrong global initialization of a union containing bitfields. This error only
  occurs if the option –BfaTSROFF is active. It's strongly recommended not to use this
  option!
- R2683 wrong common subexpression elimination on arrays indexed by register
  variable (triggered only in very singular cases)
- C++: Missed to take parenthesis in account at pointer to member initialization. For
  example:
  struct A{
    void fct(void){
      void (A::*ptrMbrFct)(void);
      ptrMbrFct=(&A::fct2);  // did generate an internal error
    }
    void fct2(void){}
  };
- R2645: C++, error message was emitted when not necessary on pure virtual function
  call.
- R2646: In the compiler V5.0.20 b0, in the "Standard Types Settings" dialog the OK
  button was not enabled.
- R2486: C++, Interrupt routines (which contain classes) are not correctly managed in
  C++ (pragma handling)
- R2300: Assertion generated with initialization of a constant structure, additional
  warning message generated.
- R2650 : when the same function is declared twice or more in a C module with
  different prototypes, a warning is generated . For example :
  int Foo (char,float,int,int* );
  int Foo (char,float,int,int**  );

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.


RELEASE NOTES CHC12 V5.0.21
  Note: These Release Notes contain some information about the C++ Compiler. If your
    license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources

List of new Features
- The ELF/DWARF 2.0 object file format is now the default. To keep HIWARE object
  file format use option -fh
- New option -ShowAboutDialog to show the about dialog
- All tools have now a dialog to edit the environment (File->Configuration). E.g. to
  modify the GENPATH.  Note that this affects the project file only (and does NOT
  support the default.env)
- The binary has now splitted into an *.exe and a *.dll part. This allows it to use as
  CodeWarrior plug-in.
- The license file is searched in following order:
- license.dat in the directory where the executable is (this was already the case)
- hiware.lic in the directory where the executable is (this was already the case)
- license.dat in one directory up from the where the executable is (this is new. E.g. if
  the executable is in c:\metrowerks\prog, the license file in c:\metrowerks is searched
  too)
- the license file using the normal FLEXlm way (usually c:\flexlm, this was already
  the case)
- R2640: new option -BfaGapLimitBits to specify the maximum gap for bit field
  allocation crossing byte boundary
- The compiler defines now also following predefined define: __MWERKS__
- For MOVB/MOVW <pc_relative>, <other_mode> the HC12 compiler behaves like
  the new Star12, i.e. the offset is always added to the address of the following
  instruction. Customers porting inline assembler sources from HC12 to Star12 please
  update the pc relative offsets for MOVB/MOVW instructions accordingly. To locate
  them easily, the compiler displays the warning "Offset of PC relative MOV
  instruction is not adapted".
- New macro __PIC__ (position independent code; this macro is defined, if compiler
  option –pic is active)
- New warning message C1861 for illegal use of type void. See manual for details.
- R2578: implement simple C++ alternate cast syntax  e = T(e)
- In the about box the most used environment variable settings are displayed too.
- R2580: The compiler does support to generate position independent runtime routine
  calls. The runtime routine code has been enhanced so that a PIC version of the library
  can be built too. See also option -PicRTS.
- New compiler option -NoPath to strip out path info out of the object files generated.
- R2517: gets() and puts() are now implemented in embedded.c. By default they use the
  terminal for input/output.
- R2566: The compiler generates warning message
  WARNING C1860: Pointer conversion: possible loss of data
  for cases where a pointer conversion may loose some data (e.g. a 16bit pointer is
  assigned to a 8bit pointer).
- R2567: overloading of qualified pointers is now supported for C++, e.g. is possible to
  use
   void foo(char *far p);
   void foo(char *near p);
- To switch off inlining completely, you can now specify -Oi=OFF. See manual for
  details.new option -AddIncl to include a header file using the command line. See
  manual/online help for details.
- R2500: code was not optimal accessing port on address zero using the |= operator
- new option -AddIncl to include a header file using the command line. See
  manual/online help for details.

List of fixed Bugs
- R2643 wrong code was generated for op-assigns on arrays indexed by a one bit
  bitfield (e.g. a[bf.i] += 2). bf.i was always taken as 0.
- R2642 internal error in glbreg.c fixed. The reason was incorrect control flow
  information on a singular case containing a 8 * 8 = 16 multiplication. Workaround:
  option –one.
- C++ switch statement and initialization, compiler does not generate exotic error
  message on ignored case statement.
- Wrong type was generated in error cases (message C1859).
- R2634, R2636: friend static object are not member of the class in which they are
  declared.
- R2626 common subexpression elimination for array accesses did not check the size of
  the base type and accessed the wrong byte (e.g. arr[i] = x;  ... (char) arr[i] did not load
  x). Workarounds for this bug: options –one (disable CSE) or –ont (disable tree
  optimization)
- R2624 internal error after branch tail merging at intermediate code level fixed. The
  compiler option –onbt did workaround the error.
- R2608: access through friendship was wrong
- The name mangling for far/near/rom/uni pointers was not as described in the manual.
  The compiler has been changed to use the correct name mangling for it as described
  in the manual.
- R2556: correction in the library routine for scanf: for %* the not assigned value was
  counted in the return value too.
- R2548: Internal error for single expressions like *((char *volatile)0x1234); fixed. No
  code will be generated for such expressions (use *((volatile char *)0x1234); to get a
  read access)
- C like struct in C++:structures containing only data objects (no functions, no base
  classes, no hidden objects...) are now treated as C like structures.  This means they do
  not contains any compiler created functions (default copy constructor, default assign
  operator...). This way this kind of C Like struct can be union field. Example:
  struct myStructType{     // no compiler created function in this structure (C like
  structure)
    char  firstField;
    short secondField;
    int   thirdField;
  };
  union myUnionType{       // an union cannot contain any object containing a
  constructor
    int          firstUnionField;
    myStructType secondUnionField;
  };
- R2500: (wish) suboptimal AND assign on memory location 0 accessed via pointer
  optimized to a single BCLR. Now, the behavior is the same for the whole zero page.
- R2480: overloaded functions list was not scanned in the right way.
- R2477: improved error message, implement a  missing pointer to member
  initialization way, when scanning '('check if type is really a function.
- R2475: init of static private class objects was not possible due to wrong access control.
- R2463: pointer to member function as parameter of a function member was not
  handled correctly.
- R2479: The compiler did not respond anymore when compiling a definition like "char
  c[0x7FFFFFFF];" because of extensive memory consumption when using the ELF
  object file format.
- R2463: missing 'this' parameter in pointer to function member type, when no
  argument specified.
- R2476: missing 'this' parameter in pointer to function member type, when 'void' was
  specified as argument.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.

Limitations
  Help System: Some topics are not available yet in the compiler help file. Requesting
  Help about such a topic opens an error window. The help topics will be extended in
  the next release.

RELEASE NOTES CHC12 V5.0.20
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
     NOTE: Recompile all your sources

List of new Features
- The high level inline assembler supports now PAGE fixups for the dc instruction and
  for the immediate addressing mode. E.g.:
     void function(void) {
       __asm LDAA #page(function);
     }
- Global initializations in ELF do now support non ANSI cases like int i; long pi= (long)&i;
- #pragma lines are now subject to macro replacement too.
  This makes it possible to conditionally set qualifiers for a segment macro, for
  example.
  Note: This may cause problems with the define NEAR =…, which is contained in
  some hidef.h header files and the segment qualifier NEAR for a "#pragma
  DATA_SEG NEAR SEGNAME" (not all processors do support this qualifier).
  As solution to this problem, the compiler does now also support additionally to the
  existing qualifiers also __XXX_SEG, where XXX is for the old qualifier, e.g.
  __NEAR_SEG for NEAR.
  So the above pragma can be written as a "#pragma DATA_SEG __NEAR_SEG SEGNAME"
- R2395: the message C4437 writes now the reason for the #error directive too. For
  unknown directives (message C4440) the name of the unknown directive is written too.
- Now port definition header files for the HC12A4, HC12B32 and HC12BC32 are
  supported. Note: The old version of the port definition files, the ports were defined
  any not only declared. This caused some problems when using it in several
  compilation units in ELF. In the new versions, a separate C file must be linked, which
  contains only the definitions. The C file is named as the header file, just with
  extension ".c".
- R2378: possible now to use nested scope local variables in HLI
- R2383: The option -Lasm does now provide more information about C++ member
  functions called
- New startup option –NoEnv which allows skipping usage of project file (project.ini)
  and default environment file (default.env)
- The TopicName for the DDE communication supports now all the special modifiers
  (%f for file name, %l for line and %c for column) too. This is useful for DDE
  Communication with CodeWright from Premia.
- For the option -ObjN: if OBJPATH is not specified with the option (e.g. –
  ObjN=$(OBJPATH)\%n, the object file is stored where the source has been found.
  The library make files already have been adapted in this way.
- %(environment variable) can be used now for all options accepting special modifiers,
  e.g. ObjN=%(OBJPATH)\%n.o can be used.
- The option -ObjN allows more than simply the %n modifier. See manual for details.
- The options -Lm, -Li and -Lo do support now file names with spaces: they are written
  with double quotes. Additionally there is a new option –LmCfg to configure the –Lm
  option. See manual for details.
- Color for output is now used: e.g. error messages are written in red
- The option -ObjN uses now special modifiers too, thus the default is now -
  ObjN=%(OBJPATH)\%n.o. See manual about details.
- Now the compiler emits an error message if any interrupt routine is declared with
  return value or any parameter.
- The C++ compiler generates now error messages (C1444, C1445) when an
  initialization is skipped by 'case' or 'default' labels.
     Example:
       void main (void){
         int i;

         switch (i){
           int myVar = 4;
           case 0:         // C1444 cause init of myVar is skipped by this 'case' label
             break;
           default:        // C1445 cause init of myVar is skipped by this 'default' label
             break;
         }
       }

List of fixed Bugs
- R2437: internal error for an assignment of a complex conditional expression inside of
  an if condition.
- R2399: empty class had size of 1 byte plus alignment, evaluation of offset between
  two nested classes was wrong.
- R2393: initialization of pointer to member array was not implemented yet.
- Indirection operator '*' is illegal on Pointer To Member operands.
- R2410: Missing destructor call before large structure return fixed. The destructor is
  called now too.
- R2397: removed nonsense load and store to a volatile memory location accessed via
  pointer and index after op assign. Example:
        volatile struct {char fld;} *p;
        p->fld &= mask;
- R2018: when tag gets same ident string as obj and not declared in typedef then the
  wrong scope was taken. Scope of obj instead scope of type.
- R2354: array of pointer to function member was parsed as array of classes.
- Avoid to generate wrong code which made the compiler looping in some error cases.
- R2369: allow to pass any array to a pointer to void during constructor initialization.
- R2364: Correction for the case where a local array of structs was initialized with a
  NULL array element. The problem was for a local initialization only. Example:
    void foo(void) {
     typedef struct {
       char *item_str;
       void (*p_item_f)(void);
     } fm_item_f_t;

     const  fm_item_f_t me_vehicle[] = {
      {"string",    NULL},    // without comma no internal error
      NULL // << this caused the problem. Workaround is to use {NULL, NULL }
     };
    }
- R2368: correction in C++ front end for the case where the left side of a virtual call
  this  pointer evaluation is an complex array operation: a pointer to the first array
  element was  passed to the virtual function instead of the pointer to the object itself.
  Example:
       this->arrayOfObjectPointers[i]->VirtualFunction();
    Workaround was to use a temporary variable.
- R2342: A buffer too small was used in embedded.c for the function scanf(). Now a
  buffer with size of  LIBDEF_SCANF_BUF_SIZE is used.
- R2343: fixing assertion in case of constant replacement optimization in the compiler,
  if the constant floating number array was initialized with integral numbers:
    const float zz[2]={0,1};
    void main(void){
      float a;
      a=zz[0];
    }
  Workaround was to initialize the array correctly with floating numbers: const float
  zz[2]={0.0f,1.0f};
- R2330: Internal compiler error for dead code containing inline assembler code.
- R2328: Explicit qualification in constructor initialization list was not possible.
  Example:
   class A {
     enum { val=0 } m_Enum;
     A(void) : m_Enum(A::val) {}
   };

- R2318: type qualifiers were not taken in account for 'new' operator parameter.
  Example:
       void fct(int param){
         char *p=(char *)new char[param];
       }

       compilation OK whereas

       void fct(int param){
         char *p=(char *)new unsigned char[param];
       }

       compilation failed !!

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.


RELEASE NOTES CHC12 V5.0.19
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
     NOTE: Recompile all your sources

List of new Features
- New -Lasmc suboption for no source prolog/epilog/function header:
  h: Do not write the function header
  p: Do not write the source prolog
  e: Do not write the source epilog
  v: Do not write the compiler version
- %c can be specified in editor configuration too to allow to open a editor with column
  information
- New function _itoa() in stddef.h which converts a integral value into a string.
  LIBDEF_StringPtr _itoa(int val, LIBDEF_StringPtr buf, int radix);
      /* writes an integral value as string into the buffer. Radix is the
         number base to be used, e.g. 10 (decimal). Returns always buf. */
- New warning message "C1857: Access out of range" which warns if there is an array
  access out of range.
    Example: char buf[3]; buf[3] = 0;
- Warning message C2705 warns now also about possible loss of data for assignments
  or argument passing.
  char c;
  long L;
  void foo(short);

  void main(void) {
    c = L; // possible lost of data
    foo(L); // possible lost of data
  }
- improved performance for constructor/destructors call in case of 1 element arrays, e.g.
     myClass *p = new myClass[1];
- new inlining of memset() and memcpy() using the -Oilib option. Additionally, there is
  now the message C5920 if a function has been inlined.
- The compiler now inlines such C++ examples:
   #define IO_REG (*((volatile unsigned int *) 0xFFC1C))
   struct IO_DEVICE{
     int receivedMessage(void){
       return IO_REG&0x0100;
     }
   };
   IO_DEVICE myDevice;
   void main(void){
     while(!myDevice.receivedMessage());
   }

List of fixed Bugs
- R2308: all type specifiers were not taken in account for declaration in switch label.
- Scope of variable declared in switch case 'block' is limited to this 'block'.
- R2290: internal error for several &= with same left value in special cases.
- Avoid internal error in compiler when initializing twice a pointer to member.
  Example:
   struct A{
               int i;
               int A::* ptr_mbr_int;
             }a;
             void main (void){
               a.ptr_mbr_int = &A::i;
               a.ptr_mbr_int = &A::i;
             }
- Definition of nested class out of containing class scope was not implemented.
   class A{
     class B;
   }
   class A::B{};
- Compiler handles access to static function member correctly now.
- Compiler handles access to members via nested classes
- R2273: internal error on shift left of an array field with four fixed.
- R2212/R2260/R2261: virtual function call missing.
- R2212/R2260/R2261: pure virtual functions were inserted in the 'object to link' list
  even if they were not defined.
- R2194: fixing possible stack overflow on host in TreeOptimizer for (!a&b) where
  both expression a and b were volatile and the result always was zero. Workaround
  was to use -Ont.
- R2191: Change the implementation of New and Delete operators, in the new.cpp
  library source file, to free the allocated memory.
- R2229: No error message was generated for a conditional relative branch to a function
  in HLI (inline assembler).
  The HC12 compiler does not support "BNE function". The last compiler version did
  not issue an error for this, instead a wrong offset was generated.
  Note: The HLI does support "BSR function".

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.

Limitations
  Help System
    Some topics are not available yet in the compiler help file. Requesting Help about such
    a topic opens an error window. The help topics will be extended in the next release.


RELEASE NOTES CHC12 V5.0.18
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
     NOTE: Recompile all your sources

List of new Features
- none

List of fixed Bugs
- This version contains an encryption support update. Encrypted files generated with
  the previous version of the compiler are not supported any more.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.


RELEASE NOTES CHC12 V5.0.17
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
     NOTE: Recompile all your sources

List of new Features
- The compiler forgets Storage Class Specifier not applied on objects and generates a
  new warning message C1135. Example:
      static class A{
        public:
          int a;
      };
- R2103: New option  -WmsgNu to suppress user messages (e.g. included files). See
  manual/help file for details.
- R2105: The WARNING C4200: Other segment than in previous declaration is now
  also produced if the definition of a variable is in the default segment and the
  declaration was in another segment. Example:
    #pragma DATA_SEG ShortSeg
    extern unsigned char bCount;
    #pragma DATA_SEG DEFAULT
    unsigned char bCount;
  This may be dangerous if the default segment access method is a different one of the
  declared one.
- R2082: It is now possible to use Assembler like syntax in HLI assembler, e.g. $12 is
  now equivalent to 0x12.
- C++: The compiler now accepts the following code without the message 'function like
  casting':
  void foo(void){
      int ((*p));    //multi level of useless parenthesis
      int ((f))(int);//multi level of useless parenthesis
  }
- R2031: the option does now also produce a listing file if there is no code generated
  (e.g. if the file contains only constants/variables).
- C++: It is now possible to inline STATIC (member or not) functions.
- New options:
  -BfaTSRON: Enable Type Size Reduction for bitfield allocation.
  -BfaTSROFF: Disable Type Size Reduction for bitfield allocation.
  See manual/online pdf for details.
- R2183: Better code for arrays allocated in a paged area without RUNTIME access.

List of fixed Bugs
- R2193: Y register conflict with a register temporary on a bit (BRSET) branch fixed by
  splitting the bit branch in a compare and branch and restoring the register temporary
  after the compare and before the branch. Such register conflicts are solved this way now.
- R2178: internal error in case of empty base classes with the -Cn=Ctr option sets.
- R2179: assertion when inlining a function dealing with static members.
- R2165: the message C1009 was not issued for a invalid struct redeclaration
- R2186: Loop unrolling was performed with global loop counters too. This is not done
  any more to avoid problems if the loop counter is used/modified outside the loop.
- R2185: Avoid assertion in not reached joining control flow. This problem occurred
  only when HLI is used (else dead code is eliminated anyway).
- R2162: The compiler handles static member functions in templates classes as well
  and generates corresponding code. Such functions were marked as not defined and
  then no code was generated.
- The compiler now generates an error message when a not static data member is
  accessed from a static function member.
- R2164: virtual function call was missing in case of call through a reference. Example:
  class A{
  public:
    A(void){ memberValue = 0; }
    int memberValue;
    virtual int getMemberValue(void){ return memberValue+1; }
  };
  ...
  class D{
  public:
    A &a;
    D(A &aC) : a(aC){}
    int getValue(void){ return a.getMemberValue(); }
  };
- C++: Static members have to be unique also in the "member list" of a class. Compiler
  generates now an error message (c1009).
   struct A{
     static int a;
     static int a;
   };
- C++: Local classes cannot contain any static data member. Compiler generates now
  an error message (c1134).
   void foo(void){
     struct A{
       static int a;            // ERROR cause static data member.
       static void myFct(void); // OK cause static function member.
     };
   }
- R2086: It was possible that the source position was wrong if the first character in the
  source was a newline only.
- R2098: PCR relative accesses to function pointers for calls in PIC code are no longer
  generated.
- R2089: For a combined assignment operation (e.g. |=) the casts on the right side of the
  assignment were ignored. Example:
    unsigned int a;
    unsigned char b;
    a |= (unsigned int)((unsigned char)(~b));
- R2088: condition not swapped for on-the-fly optimization -a < -b  ---> a > b.
- R2036: C++: Inlined constructor with initialization passing is now STATIC and not
  exported any more.
  Example:
    struct A{
      int a;
      void A(int *pa){ a=*pa; }
    };
    struct B : public A{
      void B(int *pa) : A(pa){} // pass initialization value to the base class constructor
    };                          // here the B constructor was exported.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.



RELEASE NOTES CHC12 V5.0.16
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
   NOTE: Recompile all your sources

List of new Features
- New Feature Position Independent Code.
  The new HC12 Compiler supports the generation of Position Independent Code
  (PIC). With the new option –Pic generates the compiler always Position Independent
  Code. With the new segment pragma modifier PIC position independent code can be
  generated for specific functions :

  #pragma CODE_SEG PIC PIC_CODE
  void f(void);
  void main(void) {
    f();
  }
- New Large Memory Model: In the new large memory model, all pointers contain the
  page number by default and are 3 bytes large. With the large memory model
  significant more and slower code is produced as with the Small or Banked memory
  model because the HC12 Hardware does not contain any built-in support for the
  Large Memory Model. Use the option "-ml", the startup file start12l.o and the library
  ansil.lib for the large memory model. Consider adapting datapage.c for your specific
  hardware. This reduces the time overhead of using the large memory model. When
  using another CPU derivative than the HC12A4 (for example a DG128), you must
  adapt the datapage.c for using the large memory model.
- Improved code for 'B.b1 = ~B.b1' and 'B.b1 = !B.b1' where b1 is a 1bit bit field.
- It is now possible to export (using a header file) a declared and defined variable at a
  specific address (using '@') object. For example:
  - test.h --> extern volatile union{
                   struct{
                      unsigned char b0:4;
                      unsigned char b1:4;
                   }myBitfield;
                   unsigned char myChar;
                 }myUnion @0x09;

  test.c --> #include "test.h"

                 volatile union{
                   struct{
                     unsigned char b0:4;
                     unsigned char b1:4;
                   }myBitfield;
                   unsigned char myChar;
                 }myUnion @0x09;

                 void main(void){
                   ...
                 }
- Static Constant Integral Member initialization is now handled by the C++ compiler
- New option -F6 to produce V2.6 object files
- Many compiler limitations were increased by a factor of 65536. This includes the
  number of symbols in a file, the number of macros, strings and numbers.
- The new keyword __va_sizeof__ returns the size of the specified object/type on the
  stack when passed as open parameter. Therefore especially __va_sizeof__(char)
  returns sizeof(int) and __va_sizeof__(float) returns sizeof(double).
  With the keyword __va_sizeof__ it is possible to write stdarg macros which allow the
  usage of character variable in the va_arg macro. According to ANSI-C the behavior in
  this case is undefined.
  E.g.
  sizeof(char)           :  1 (unless otherwise configured
                               in the type size dialog)
  __alignof__(char[100]) : returns 1 (some targets also >1)
  __va_sizeof__(char)    : returns sizeof(int) because
                           characters are promoted to int
- The entry
  #define MAXLINE      255 /* maximum buffer used for scanf() */
  has been removed from embedded.h, the entry
  #define LIBDEF_SCANF_BUF_SIZE         255 /* buffer size needed in scanf: may
  be reduced to save RAM */
  in libdefs.h is used instead. The libdefs.h header file is used to configure the ANSI
  library behavior and may be adapted by the customer.
- New options -Ekey and -Eencrypt to deal with encrypted files. With this options it is
  possible to encrypt files and later to compile them without a need for the original
  source. See manual for details
- Demo limitation of 800 bytes of code has been increased to 1024 bytes of code
- New compiler define __DEMO_MODE__ if the compiler runs in demo mode
- Improved compilation speed for treeopt optimization

List of fixed Bugs
- R2008: Internal Error for 'void' statements like (void)p->a |= x fixed.
- R1988: correction for assertion in front end if there is no actual function object while
  compiling a C++ file
- R1994: tree optimizer did optimize statements if there was a cast on the root of a
  statement: the statements after were optimized. Example: (char)buf[3]++; i++;
  Workaround was to specify -Ont.
- Do not generate a NULL check pointer if delta is 0 in the following cast expression:
  class A{
    //...
  };

  class B{
    //...
  };

  class C : public A, public B{
    //...
  };

  void main(void){
    C *pc = new C;
    B *pb;
    A *pa;

    pb = pc; // this assignment will be interpreted as pb=(B*)((char*)pc+delta(B));
             // Here delta is different from 0. In case of pc is NULL, pb has to
             // become NULL as well. That's why one has to generate the following code
             // pb = (pc==0) ? 0 : (B*)((char*)pc+delta(B));

    pa = pc; // but here delta is 0, then generating such code is useless:
             // pa = (pc==0) ? 0 : (A*)((char*)pc+delta(A));
  }

  class C object memory layout:
         pc and pa ---> +-----------+   +
                        |   A part  |   | delta(B)
                pb ---> +-----------+   +
                        |   B part  |
                        +-----------+
                        |   C part  |
                        +-----------+

- Generate the following error message "Invalid redeclaration of enum type" only if it is
  really a enum type redefinition and not for example a function's return type.
- Generate information about interrupt function even in case of class member functions.
  Such a definition
  interrupt 5 void my_class::f(void) { };
  is supported now.
- Avoid compiler assertion in error cases when using the cC++ language without any
  Constructor
- In case of a sign extension with a question mark operator, the sign extension was
  moved after the evaluation of the question mark operator. But for statements after the
  operator, the statements afterwards were ignored. The workaround was to use the
  option -Ont. Example: (cond) ? (int)(ch1=0) : (int)(ch1=1); Note: The problem has
  exist only if the '?' operator was used in a statement.
- A wrong register preassignment with option –or in functions containing switches is
  corrected.
- Avoid compiler assertion in error cases when using the cC++ language without any
  Constructor
- In case of a sign extension with a question mark operator, the sign extension was
  moved after the evaluation of the question mark operator. But for statements after the
  operator, the statements afterwards were ignored. The workaround was to use the
  option -Ont. Example: (cond) ? (int)(ch1=0) : (int)(ch1=1); Note: The problem has
  exist only if the '?' operator was used in a statement.
- Internal error fixed for function parameter zero extended from char to long. The error
  appeared only if the constant 0 is used frequently in the context of the function call.
- Internal error fixed for unused expression with volatile access to a field of a structure.
  Example:  s.f == 1;
  The error did only occur for structure field accesses with objects declared volatile and
  others not. (e.g. volatile struct { int f;} s; s.f; ---> internal error, volatile struct
  {volatile int f;} s; s.f; ---> ok).
- Missing qualification at C++ constructor call corrected.
- Volatile assignments, which can be handles by a memory operation, did produce a not
  necessary load/store or move instruction.
- After include directives with a macro name for the filename, the line numbers were
  sometimes wrong.
- Assertion bug for a character bit field shifted left with 1 fixed. The bug occurred
  while combining two shifts left (one additional shift left for bit field extraction) into
  one with the sum of the shift counts.
- Bug in branch optimizer fixed. The bug appeared at some singular context when
  JMP's were optimized to BRA to BRA sequences to the same target label.
- Dereferenced pure virtual function calls are correctly handled now.
  class A {
  public:
    virtual int f(void) = 0;
  };

  class B : public A {
  public:
    int f(void){ return 6; }
  };

  static void test1(void){
    B b;
    A* pa= &b;
    if (pa->f() != 6) {
      Err(1);
    }
  }
- Static member access correctly handled now.
  class A {
  public:
    static int b;
  };

  int A::b=9;

  class C {
  public:
    static int retSum(void){ return A::b; };
  };
- Pre-processor handles following examples in the right way now:
  - C++ comments:
  #define VALUE /##/
  VALUE blablablabla
  - Missing parameter:
  #define fct(A, B) int A B

  void main(void){
    fct(i, );
  }
  - Expansion troubles:
  #define m(a)    a(w)
  #define w       0,1

  m(m);

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.


RELEASE NOTES CHC12 V5.0.15
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
   NOTE: Recompile all your sources

List of new Features
- Because the result of casting a (signed) floating value to a unsigned integral value
  is undefined in ANSI-C, there is now a warning message for that (C5919, see also
  manual).
- There is now a -View option which allows to specify if the application window
  runs as normal window, full screen, minimized, maximized or hidden. See manual
  for details.
- The Compiler has now a new icon, so it is much easier now to identify the
  Compiler if the window is minimized in the task bar.
- The -Oilib option to inline ANSI library function has been extended. It is always a
  good thing to set this option if you don't want to implement your own library
  functions, because it increases the code speed, and in many cases it also reduces
  the code size.
- various compiler limitations has been extended and refined. See also Manual
  "Translation Limitations" for details.
- maximum recursive expansion level has been increased from 70 (16bit OS) to
  2048 (32bit OS). See also message C4412.
- maximum number of macro parameters has been increased from 1000 to 1024.
  See also message C4428.
- Nesting levels for#include files has been increased from 32 to 256. See also
  message C3000.
- better error handling in case of a preprocessor error.
- the previous declaration of fabs in math.h
      #ifdef __OPTIMIZE_FOR_TIME__ /* use inline version */
        #define fabs(d)  ((d)>=0.0  ? (d) : -(d))
        #define fabsf(f) ((f)>=0.0F ? (f) : -(f))
      #else
        extern double fabs(double);     /* absolute value */
        extern float  fabsf(float);     /* absolute value */
      #endif
    has been replaced with
      extern double fabs(double);     /* absolute value */
      extern float  fabsf(float);     /* absolute value */
    that is the macro version has been removed. The reason is that using a macro
  may be a dangerous thing:
      d = double(d++); // d++ is evaluated twice using a macro
  To get the same optimal code, the -Oilib option provides an option to inline fabs
  and fabs (see manual for details).
- The library now contains startup.h and startup.c: this is a generic startup code
  written in C you can use and adapt. Note: for code efficiency reasons it is
  recommended to use still the startup code written in HLI.
- The library now includes also following files (which were present in the demo
  directory previously:
    - inout.h, inout.c
    - terminal.h, terminal.c
    - termio.h, termio.c
  If you want to use your own terminal interface, just adapt the termio.c and link it
  in front of the ansi library to replace the version in the library.
  Additionally there is
    - embedded.h, embedded.c
    which is an interface to resources normally not available on an embedded target.
  This interface is for simulation only and contains the implementation of following
  functions:
    - fopen()
    - fflush()
    - fclose()
    - fprintf()
    - fputs()
    - fputc()
    - printf()
    - scanf()
    - clock()
    - abort()
    - exit()
- Previously the heap in heap.c was initialized during copy down (static
  initializations). This approach has used depending on the heap size a lot of ROM.
  The initialization is done now during the first malloc, requiring only 1 byte of
  RAM.
- There is now a warning C3804 if a predefined segment name is used, e.g. #pragma
  CONST_SEG ROM_VAR, because this may raise conflicts during linking
- For redefinition of an existing macro, the position information of the previous
  macro definition is also provided.
- The number of errors, warnings and information messages is now reported at the
  end. Additionally, if more than one file is specified on the command line, the
  processing does not stop any more on the first error file. It tries to process now all
  the files specified and reports at the end the total number of errors, warnings and
  information messages.
- Improved floating point performance for addition, subtraction, multiplication and
  division: operations are performed on single precision arithmetic if possible
- Improved comparison optimization: the compiler folds sequences of comparisons
  into or operations or backwards into comparisons if better, e.g. 'a == 0 && b == 0'
  may be more optimal written as '(a|b)==0'.
- The -OiLib option allows now also inlining of strlen if the string is constant, e.g.
  using -OiLib, 'strlen("01")' will be directly replaced by '2'. You can use '-OiLib=b'
  to switch this off.
- The compiler defines now the macro __MODULO_IS_POSITIV__ if the result of
  the modulo operation is always positive (e.g. for a M68HC11 CPU). In ANSI-C
  the result of (-22%4) can be either 6 or -1. If it is 6, then the macro
  __MODULO_IS_POSITIV__ is defined. This helps to write portable code across
  different platforms (see manual for details).
- The compiler emits now a warning for PC relative addressing modes in MOVB or
  MOVW instructions. The PC relative offset of such instructions must be specially
  adapted. For details see CPU12 Reference Manual, Freescale, Inc, 1996, Chapter
  3.9.1. Move Instruction
- Destructors of global objects in C++ are now called when using the ELF-object
  file format and a linker with version at least V5.0.5.
- Unary Operator (__alignof__(type-name)):
  Some processors require aligning objects according to their type. This unary
  operator can be used to determine the alignment for a specific type. By providing
  any type, this operator returns the corresponding type alignment. This operator
  behaves in the same way as "sizeof(type-name)" operator. See target back-end
  section to check which alignment corresponds to which Fundamental Data Type
  (if any is required). This operator may be useful for the va_arg macro in stdarg.h,
  e.g. the alignment of a structure containing 4 objects of 4 bytes and the one of a
  structure containing 2 objects of 8 bytes are different and the size of those
  structures are the same:
     #define va_arg(ap,type)    \
       (((__alignof__(type)>=8) ? \
        ((ap) = (char *)(((int)(ap) \
        + __alignof__(type) - 1) & \
     (~(__alignof__(type) - 1))))\
         : 0), \
       ((ap) += __va_rounded_size(type)),\
       (((type *) (ap))[-1]))
- If the options -Li, -Lm or -Lo are specified, code is generated too.
  Previously no code was generated if one of these options was specified (as
  stated in the manual).
- It is possible now to 'brace' the -OdocF option using '(' ')', '"' '"', '[' ']', '{' '}'. If no
  spaces are used between the option, braces are not necessary. Examples:
    -OdocF="-Cni|-Or"
    -OdocF=-Cni|-Or
    -OdocF=(-Cni|-Or)
    -OdocF=[-Cni|-Or]
    -OdocF={-Cni|-Or}
- Following special case is handled yet: for 'int arr[25];' 'sizeof(0,arr)' is now the
  same as sizeof(&arr[0]), whereas 'sizeof(arr)' is '25*sizeof(int)'.
- The compiler implements now the #line directive
- strxfrm() and strcoll() implemented in the string library
- C++ comments are not allowed any more if the compiler options -Ansi is set. Of
  course they are allowed for C++ source files. To enable C++ comments ('//') even
  if -Ansi is set, you have to specify the -Cppc option.
- <printf> and <scanf> functions support now FAR pointers:
  There are new type characters that extend the behavior of these functions:
  - for <printf> function:
    'P': FAR pointer to void (void *FAR)
    'S': FAR string (char *FAR)
    'N': FAR pointer to integer (int *FAR)
         (the variable where the number of items written is to be stored)
  - for <scanf> function:
    '+': FAR qualifier
         (the following type character is qualified as FAR)
    'P': FAR pointer to pointer to void (void **FAR)
    'S': FAR string (char *FAR)
    'N': FAR pointer to integer (int *FAR)
         (the variable where the number of items written is to be stored)
  The library files printf.c and scanf.c contain defines where the new behavior can
  be configured.
- For HLI blocks ('asm { ...'), sometimes an error message was displayed for the next
  line and not for the line where the error occurs. This has been improved, so the
  error message is displayed now on the correct source line.
- Header files for the 68HC12A4 (file 6812a4.h) and 68HC12B32 (file 6812b32.h)
  are now included with the library header files
- The output format of the assembly listing file generated by -Lasm has been
  improved
- C++ comments are not allowed any more if the compiler options -Ansi is set. Of
  course they are allowed for C++ source files. To enable C++ comments ('//') even
  if -Ansi is set, you have to specify the -Cppc option.
- The asm keyword is not allowed any more if the –Ansi (strict ANSI) is specified.
  The reason is to be compliant with ANSI rules tested by independent test suites.
  E.g.
  int asm; // allowed in ANSI-C
  has to be allowed if –Ansi is set, thus 'asm' cannot be a keyword. You will
  encounter error messages if you try to compile sources with –Ansi which contain
  'asm' keywords. But you can use __asm instead asm:
  __asm {….
  - For all non ANSI keywords as "far", "near", "interrupt", "paged", "uni", "rom"
  and "asm" there is now an additional from with two leading underscores ("__far"
  for "far,.. ).
  The version with the underscores is available even when the option "-Ansi" is
  specified. The old style form is not present with "–Ansi".
  Note : Not all keywords are supported in all targets.

List of fixed Bugs
- Actually unused strings are no longer written into the object file. With the ELF
  object file format or with the new HIWARE linker, these strings were allocated
  when smart linking was explicitly switched off.
  Example :
  const char buf[100]="Buffer".
- Correction for the HIWARE object file format were the object list in the object file
  was written twice. This had no effect on the tools, but had increased the object file
  size.
- Following initialization was allowed:
  Typedef union myUnion_t{
    int a;
    char b
  }myUnion;
  myUnion obj=3;
  whereas curly braces are missing (now C2206 error message is generated).
- Serious code generation bug in a switch statement having a default label as first
  label fixed.
- Pre-processor handles following example in the right way now:
  #define STR(a) NXSTR(a)
  #define NXSTR(a) #a
  #define f h
  #define h(a) a+f

  char *p0 = STR( f(1)(2) );
  /* the result has to be "1+f(2)" or "1+h(2)" and not "h(1)(2)" */
- Pre-processor handles following example in the right way now:
  #define STRING_A(s) #s
  #define CAT1(a, b, c) STRING_A(a) STRING_A(b) STRING_A(c)

  #define FIRST Hicross+
  #define SECOND From
  #define THIRD Hiware

  static char *b = CAT1(FIRST,SECOND,THIRD);

  /* result has to be "Hicross+FromHiware" */
- The treeopt optimizer did produce wrong compares in some cases for cases like
  "30 – var < 8".
  This bug did occur in special situations when the left and right side did only
  contain constants and one variable.
- In pre-processor: '.' ## "string" is a legal concatenation now.
- The compiler did assert in rare cases with a function with many switches with
  dense case entries and common code before the switches.
- Default argument placeholder functions have not to be taken in account as virtual
  functions.
- A spill between a compare and a conditional branch did destroy the condition flags
  in certain circumstances. The PSHC to save the flags was incorrectly behind a
  store. This bug did only happen when a variable was spilled and reloaded between
  a compare and a conditional branch.
- Some temporary files were not deleted in some specific error cases.
  The temporary files are named "~tmp1", "~tmp2" and so one. They are located in
  the system temporary directory. To find the system temporary directory, open a dos
  box and enter "echo %TMP%" and hit return.
- Hexadecimal and octal escape sequences do behave differently.
  A hexadecimal escape sequence does no end for the first non-hex digit. Octal
  escape sequences are ending at the first non-octal digit or after at most 3 octal
  digits.
  E.g. "\x0102" issues now the error "ERROR C4418: Illegal escape sequence",
  while previous versions did recognize "\x010" "2".
- Pure virtual functions have to be defined only if they are called with an explicit
  qualification.
- Duplicated virtual functions into virtual tables.
- Some special char times char multiplications did cause an endless loop in the
  compiler. Because in this loop some memory was allocated, the compiler did fail
  because of a memory failure.
- in HLI (high level inline assembler) expressions using labels were not correctly
  evaluated. Instead of the current value of the label, just 0 was used. Now such
  expressions raise an error "label addressing mode not supported".
  Note : Labels can be used only as branch targets.
     #pragma NO_EXIT
     const char* retAdrOf7(void) {
       asm {
            LDD #label
            RTS
     label: DC 7
       }
     }
- The compiler did assert some situations where an array was accessed after an
  autoincrement /autodecrement.
  Example :
     int arr[5];
     void main(void) {
       char i;
       if (!arr[i]--) {
         arr[i] = 0;
       }
     }
- Constant accesses to constant arrays of structures were not only correctly handled.
  The wrong constant was returned.
  In the example, main did incorrectly return 2 instead of 4.
     struct A {
       char a;
       char b;
     };
     const struct A arr[2] = {
       {1,2},
       {3,4}
     };

     int main(void) {
       return arr[1].b;
     }
- Line continuations may now also occur inside of identifiers
- When after the backward slash a space is following, this is no longer treated as
  line continuation. Remove the space if you want a line continuation.
- Correction for calloc: the memory was not initialized correctly
- Correction for a case where the compiler has detected the if-else part with HLI as
  the same.
- The treeopt optimizer did incorrectly remove switches with a constant switch
  condition, which was only satisfied by a default label.
  Example :
     void main(void) {
         switch(10) {
          case 1: ...
          case 9: ...
          case 11: ...
           default: .... /* this code was not executed */
       }
     }


- Implicit initialization of floating point values in local structures or arrays did raise
  an internal error. This problem did only occur under the following conditions :
- local variable to be initialized
- not all floating point values were explicitly given
  Example :
     void main(void) {
    float f[2]= {1.1};
  }
- The type character "%p" in <scanf> function family requests now the correct type
  which is a pointer to a pointer to character (char **) instead of a pointer to a
  character (char *).
  The optional prefix to type 'L' which specified the size (long) of a type character,
  requests now a long for "%Ld" and "%Li" instead of an integer in <scanf> function
  family.
- For structured zero page variables with the option -la, the compiler does no longer
  define some labels in the generated inc file. Therefore this file can be included into
  several assembler file.
  Example : for
     #pragma CREATE_ASM_LISTING ON
     #pragma DATA_SEG SHORT short
     struct {
       int i;
       int j;
     } Test;

     The compiler currently generates:
     XREF.B Test
     Test_i                  EQU.B Test + $0
     Test_j                  EQU.B Test + $2

     Note : Check that your assembler encodes accesses like
     LDD Test_i
     With a 8 bit access ignoring the.
- The compiler accepts now functions used in complex comma expressions:
  fktPtr = (expr, function);
- The compiler did loop forever while preprocessing macros (singular case).
- Internal error after switch table optimization in context with common code movement
  fixed.
- Internal branch tail merging error fixed for expressions like (a = = (<cond> ? b : b))
- Internal SSA consistency test error after branch tail merging fixed.
- Invalid memory equivalence was used for register – register addition. This is fixed
  now by checking the current definition of the memory equivalence.
  Bug example:
     DataIn.Data[DataIn.Index++] = TempChar;
- Register Induction Variable defined by a expanded shift was not loaded before the
  loop. The bug only occurred when the loop has no body.
  Bug example:
     void main(signed int i) {
    i /= 2;
    while(i-- > 0) {}
  }

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
   WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.


RELEASE NOTES CHC12 V5.0.14
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
   NOTE: Recompile all your sources

List of new Features
- The startup code of version V5.0.12 and V5.0.13 did always define the reset vector
  at address 0xfffe to the function _Startup. With this setup, it was not possible to
  use this startup code without modifications for the system where the reset vector is
  already used, for example by a rom monitor. So the reset vector is defined by the
  new startup code only when the command line option "-
  D__SET_RESET_VECTOR__" is additionally specified when the startup code is
  compiled again. The pre-compiled version of the startup code (start12s.o and
  start12b.o) does not define the reset vector anymore.
  To define the startup vector in the prm file, add the following line in your link
  parameter (prm) file :
     VECTOR ADDRESS 0xfffe _Startup

List of fixed Bugs
- CHC12 V5.0.13 had a sever bug with the Option -D. This bug was fixed with this
  new version. The option -D did work in previous version (e.g. V5.0.12).
- The runtime support function for long division 32/32 bit did have a bug in some
  rare cases. So dividing 29940090 by 116955 did result in 0 instead of 255.
  This bug is corrected in this release of the runtime support in rtshc12.c.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- For structured zero page variables with the option -la, the compiler defines some
  labels in the generated inc file. Therefore this file can in this case only be included
  by one assembler file. The next compiler version will only define such labels with
  an EQU.B, but the current assembler does not generate 8 bit accesses to labels
  defined with EQU.B.
  Example : for
     #pragma CREATE_ASM_LISTING ON
     #pragma DATA_SEG SHORT short
     struct {
       int i;
       int j;
     } Test;

     The compiler currently generates :
     XREF.B Test
                             XDEF.B Test_i
     Test_i                  EQU.B Test + $0
                             XDEF.B Test_j
     Test_j                  EQU.B Test + $2
     The next compiler version will no longer write the XDEF.B.
     The current assembler encodes without the XDEF.B an access like:
     LDD Test_i
     With a 16 bit access ignoring the ".B" after the EQU.
  But the current way, every assembler file reading the XDEF.B's does define
  the label Test_i and Test_j such that several such assembler files cannot be
  linked together.
  Note: the current linker in the HI-WARE Object file format does sometimes
  core dump in this error case.
- C++ Destructor calls for global class objects (HIWARE and ELF/DWARF object
  file format). The startup code does not support calling destructor functions.
     class A {
       int m;
       ~A();
     };
     A a;     // not calling destructor at end of program
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf, switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
   WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info does not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.


RELEASE NOTES CHC12 V5.0.13
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources

List of new Features
- The global and local editor can now be configured also in this tool and not only
  with the shell.

Note:
- The global editor is stored globally in the mcutools.ini. The same editor
  configuration is used by all tools (decoder, compiler, assembler,....).
  Changes to the global mcutools.ini are stored when the application is closed and
  not when the save command is chosen from the menu.
- The local editor is shared among all tools using the same project file (usually
  project.ini).
- Which editor type is used is stored in the project file. The default is the global
  editor.
- The previous release has written the compiler options as string into the object file.
  But if the user switches off smart linking in the linker, those options are linked too
  in the ELF/DWARF object file format. So this options are not any more written into
  the object file format.

- The compiler optimizes now for loops into do..while loops if the code is more
  compact. This results in faster code too.

- All error messages are now written to stdout. With WinEdit the 'Capture Output'
  feature in the Project->Configure dialog can be used to get the error feedback. In
  other applications as Microsoft Visual C++ Developer Studio (MSDEV) or the
  cmd.exe command shell, it is necessary to use the new launcher application
  'piper.exe' to get direct error feedback. The compiler is a Win32 Window
  application and this type of application is not expected to have reasonable output.
  So the command shell 'cmd.exe' or MSDEV do not use the stdout file.
  The 'piper.exe' tool is actually a Win32 command line application and therefore
  MSDEV or 'cmd.exe' use the stdout.
  The first argument of 'piper.exe' is used as application to be called with the
  remaining options. The output of the started application is then written to standard
  output.
  To print the list of option in a command window use:
  (instead of tool use the compiler/linker/... name).
     piper.exe tool.exe -h

- If there is a nameless struct or union (e.g. typedef struct _tagStruct { int a; };), now
  the tag name is written to the object file too for better debugging support.
  Additionally there is extended debugging support for enumerations, that means for
  the following source debug information is available for the enumeration values
  RED, GREEN, BLUE, WOOD, STONE, IRON and MARBLE:
    enum Color_tag { RED, GREEN, BLUE} Colors;
    enum Color_tag taged_color;
    typedef enum Material_tag { WOOD, STONE, IRON, MARBLE} Materials;
    enum Material_tag taged_material;
    Materials material;
- New option -LicA to display license information about every possible feature in the
  directory where the executable is. Note: this option requires some time to get all
  features out of every file in the directory and may take a long time
- correction for CSE problem (compiler option -Oc): The compiler has produced
  wrong code for the following complex example:
  static void test(STRUCT1 *ptr) {
    if (Array[ptr->byte1] > (structArray[ptr->byte2].byte4
         + structArray[ptr->byte2].byte3))
    {
      Array[ptr->byte1] -= structArray[ptr->byte2].byte3;
    } else {
      Array[ptr->byte1] = 0;
    }
  }
- PC only: This version is a true 32bit version only, it cannot run under Win32s any
  more. If you are still using Win32s, either upgrade to Windows 95 or WinNT 4.0. If
  this is not possible, please contact us. The reasons not to support Win32s any more:
- Most hardware vendors do not support their chips with Win32s tools any more,
  thus if we support such target interfaces, it is not possible to run our tools under
  Win32s
- Microsoft does not support 16bit applications nor Win32s
- Using a lot of graphical user interface (as in HI-WAVE), Win32s is quite instable,
  e.g. some dialog boxes may behave differently in Win32s than in a true Win32
  environment
  The 32bit application needs two additional DLL's which are copied to your
  Windows system directory: mfc42.dll and msvcrt.dll
- This version introduces the FLEXlm license management which allows a very
  flexible licensing (PC only):
  - floating licenses (client-server)
  - node locked licenses (single workstation)
  - dongle optional
  Running a tool without any license manager switches the tool to a restricted demo
  mode (see 'Demo Version Limitations' below). The about box gives an overview
  with the current host id and the status of each feature/license. The license manager
  consists of following parts:
- the license manager dll 'lmgr326a.dll': this license dll is normally installed where
  the tools are (default c:\hiware\prog\lmgr326a.dll'), but it is also possible to place
  this dll into the Windows system directory or wherever your operating system
  searches for a dll.
- the license file. The name of the license file is either 'hiware.lic' or 'license.dat'.
  This file is a normal text file and normally placed into the same directory as your
  tools are installed, usually 'c:\hiware\prog'. This license file contains all features
  enabled on your site, everything else without a license is in a restricted demo mode.
  If you do not have a license yet, you can request one sending us the content of the
  about box to 'register@hiware.com'.
- The option -Lp (preprocessor output) accepts now an optional file specification, e.g.
  -Lp=%n.pre (see manual for details) (which is also the default). The TEXTPATH
  environment variable is used if the preprocessor output file name does not contain a
  path (NOTE: a relative path is a path too!).
- New option -NoBeep to disable the beep in case of an error.
- It is now possible to redirect the message output to a file if a tool is started using a
  command shell. Example: 'c:\hiware\prog\linker.exe fibo.prm > output.txt'. NOTE:
  if a tool launched by a command shell under Win95, you have to add '/wait' to the
  start command if the shell has to wait until the started application terminates, e.g.
  'start /wait c:\hiware\prog\linker.exe fibo.prm'.
- New warning message 'C1805: Non standard conversion used' if a object pointer
  (e.g. a pointer to a struct) is  assigned to a function pointer. Previously there was an
  error message 'C1806: illegal cast operation' for this case.
- It is now possible to check in the source if an option is active. The EBNF grammar
  is
  OptionActive = "__OPTION_ACTIVE__" "(" string ")".
  It can be used in the preprocessor and in C code too:
  #if __OPTION_ACTIVE__("-W2")
    // option -W2 is set
  #endif

  void main(void) {
    int i;
    if (__OPTION_ACTIVE__("-or")) {
      i=2;
    }
  }
- New virtual function management: avoid to create virtual table pointer when it is
  possible (less virtual tables, less code).
- New defines __LITTLE_ENDIAN__ and __BIG_ENDIAN__ to identify the data
  allocation. See manual for details.
- New option -Lic to display license information (note: this information is also
  displayed in the about box)

List of fixed Bugs
- In the ELF/DWARF 2.0 output of the Compiler, some constructs written in previous
  versions were not confirming the ELF standard. Because old versions of the debugger
  are not able to load the corrected new format, the old behavior can still be produced
  by using "-f2o" instead of "-f2". Some old versions of the debugger do even generate
  a GPF when a new absolute file is loaded. If you want to use such old versions, please
  use "-f2o" instead of "-f2". New versions of the debugger are able to load both
  formats correctly.
- The EMUL instruction was in some mixed signed/unsigned cases incorrectly used.
  The sign bit of the operands was not correctly treated according to ANSI.
- The manual described the option "-prod" to expect a "=" and then a filename. But the
  implementation did expect the filename after a space. The new implementation now
  follows the manual description
     -prod=c:\hicross\demo\project.ini
- Absolute objects (*(int*)1000) were taken to be equivalent to objects previously or
  afterwards assigned to them.
- The inline assembler did not correctly handle BRSET / BRCLR with the Accumulator
  Offset Indexed Addressing.
- Template class with multiple inheritance having base classes generated of same
  template and Constructors calling base class Constructors corrected !
  Example:
     template <class T> class foo {
        public: foo(char l) {};
     };
     template <class T> class hoo : public foo<T>, foo2<int> {
       public: hoo(char id, char dir): foo<int>(1), foo<T>(2) {};
     };
     hoo<char> P(1,2);
- Avoid generating a virtual function call where it was not necessary.
- The Compare Peephole optimization -onp=q did incorrectly optimize compares
  away.
  In assembly code like :
     CPX aaa
  BNE L100
  LEAX 3,X
  CPX aaa
  BNE L101
  The second CPX was removed. This bug did only occur together with a LEA
  because LEA's do no change the condition code.
- When either a -D or a -I option was specified in the "COMPOPTION" entry in
  default.env, this option was added every time again to the options in the project.ini
  option string.
  The adding was marked with a note on the log and the whole option string was
  printed with several instances of the -D or -I option.
  Now the compiler states that the additional -D or -I entry was ignored and only one
  entry of any string is added to the project.ini file.
- The compiler did not recognize all illegal implicit casts in C++ from or to void*.
  Now they give an error message.
  Example
     void * pv;
     int i;
     void main(void) {
       pv=i; // now gives an error message when using C++
             //and a Warning in C
     }

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HIWARE and ELF/DWARF object
  file format). The startup code do not support calling destructor functions.
     class A {
       int m;
       ~A();
     };
     A a;     // not calling destructor at end of program
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf ,switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
     WARNING C12056: SP debug info incorrect because of optimization or inline assembler
- The options -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info do not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
- Preprocessor directive #line not implemented, the directive is ignored.


RELEASE NOTES CHC12 V5.0.12
Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.

NOTE: Recompile all your sources

List of new Features
- C++ libraries STL, "bitset", "strstream" added.
- The startup code now defines the reset vector.
  The reset vector points to the function _Startup. Previous versions of the startup code
  did not set the reset vector, so linking with the new startup code may fail when a old
  prm file also defines the reset vector.
   If you want to use the startup code, but not that the reset vector does points to
  _Startup, please remove the interrupt vector number and recompile the startup code.
  Be aware that until this version the reset vector had to be defined explicitly in the
  startup code. With the change in start12.c and its derived files, the reset vector is now
  defined automatically. Please remove the startup vector initialization in your prm files,
  or change the startup code and its header file to not use the interrupt number 0.
  Please change the code in both the c and in the header file.
     /* declaration/definition of _Startup which also
     defines the Reset Vector : */
     void interrupt 0 _Startup(void);

     /* declaration/definition of _Startup which does
     not define the Reset Vector : */
     void interrupt _Startup(void);
- The ANSI library is now delivered splitted from the C++ library.

    Also the library is now delivered in two object file format versions, HIWARE and
    ELF/DWARF 2.0.
    The HIWARE object file format libraries are contained in the "lib.hix" directory, the
    ELF/DWARF 2.0 libraries in the "lib" directory.
    Currently, the following libraries are delivered :


    Library       File                Memory Model   double    Object format  used options

    ANSI          lib\ansis.lib       SMALL          IEEE32    ELF            -ms -f2
    ANSI          lib\ansib.lib       BANKED         IEEE32    ELF            -f2
    ANSI          lib\ansisf.lib      SMALL          IEEE64    ELF            -ms -cf -f2
    ANSI          lib\ansibf.lib      BANKED         IEEE64    ELF            -cf -f2
    ANSI          lib.hix\ansis.lib   SMALL          IEEE32    HIWARE         -ms -fh
    ANSI          lib.hix\ansib.lib   BANKED         IEEE32    HIWARE         -fh
    ANSI          lib.hix\ansisf.lib  SMALL          IEEE64    HIWARE         -ms -cf -fh
    ANSI          lib.hix\ansibf.lib  BANKED         IEEE64    HIWARE         -cf -fh

    C++           lib\cpps.lib        SMALL          IEEE32    ELF            -ms -f2 -c++f
    C++           lib\cppb.lib        BANKED         IEEE32    ELF            -f2 -c++f
    C++           lib\cppsf.lib       SMALL          IEEE64    ELF            -ms -cf -f2 -c++f
    C++           lib\cppbf.lib       BANKED         IEEE64    ELF            -cf -f2 -c++f
    C++           lib.hix\cpps.lib    SMALL          IEEE32    HIWARE         -ms -fh -c++f
    C++           lib.hix\cppb.lib    BANKED         IEEE32    HIWARE         -fh -c++f
    C++           lib.hix\cppsf.lib   SMALL          IEEE64    HIWARE         -ms -cf -fh -c++f
    C++           lib.hix\cppbf.lib   BANKED         IEEE64    HIWARE         -cf -fh -c++f

    Startup C     lib\start12s.o      SMALL          ----      ELF            -ms -f2
    Startup C     lib\start12b.o      BANKED         ----      ELF            -mb -f2
    Startup C++   lib\strt12sp.o      SMALL          ----      ELF            -ms -f2 -c++f
    Startup C++   lib\strt12bp.o      BANKED         ----      ELF            -mb -f2 -c++f

    Startup C     lib\start12s.o      SMALL          ----      HIWARE         -ms -fh
    Startup C     lib\start12b.o      BANKED         ----      HIWARE         -mb -fh
    Startup C++   lib\strt12sp.o      SMALL          ----      HIWARE         -ms -fh -c++f
    Startup C++   lib\strt12bp.o      BANKED         ----      HIWARE         -mb -fh -c++f


List of fixed Bugs
- Inline assembly comments could produce an error, if illegal numbers were written.
  Now they are skipped correctly by the parser.
- interrupt functions declared without "interrupt" and then defined with "interrupt" were
  encoded like non interrupt functions.
- for interrupt functions declared and defined with a interrupt vector number, the vector
  was not set. It did work when only at the declaration or the definition the vector
  number was specified.
- Interrupt vector entries were defined several times when using -odocf.
- The Load/Store Peephole optimization did not correct handle a double
  dereferenciation.
- The Common code optimization did not correctly realize the size of the stack
  arguments for far function pointer calls using the _FCall runtime routine.
- Some very special cases of 16 or 8 bit assignments did generate the message :
  ERROR: C12020: Unknown Operand Combination: Opr1:Imm16/Opr2:IdxInd16.
  Example :


     typedef struct {
     int i;
     } A;
     A ** ppa ;

     void main(A** ppa2) {
     ppa= ppa2;
     * ppa = ( ( A* ) 0 );
     ppa = ppa2 + 1 ;
     }

- Register trace does no assume that any registers are valid across HLI blocks :
  When mixing HLI and HLL no registers need to be saved anymore.
- Declare Constant Byte in inline assembler does now always allocate the right sizes,
  even if a fixup to a larger object is involved.
  Example:
     char a;
     DC.B a     ; allocates now 1 byte
- The common subexpression elimination (option -Oc) was removed because it very
  often generated more code then without it and because it did not consider all
  possible alias cases. The option is still present to keep compatibility. In future
  versions this option might be removed.
- The -OdocF option does now care about illegal options. The usage of a option
  which cannot be set at function level (e.g. a memory model, which must be
  consistent across the application) generates a compile time error.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
  - C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object
  file format). The startup code do not support calling destructor functions.
     class A {
       int m;
       ~A();
     };
     A a;     // not calling destructor at end of program
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf ,switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
     WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The option -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info do not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
- Register parameter does not generate debug info, when it is not allocated on the
  stack. Note that even when it is stored with a PUSH, it is not clear if it is allocated
  on the stack. The PUSH may also be generated by a spill. This situation often
  occurs in small C++ member functions, where only the this pointer is passed and
  the this pointer is directly used.


RELEASE NOTES CHC12 V5.0.11
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
     NOTE: Recompile all your sources

List of new Features
- In the ELF object file format, both far and near function pointer can be used.
  This feature is not supported in the HIWARE Object File format because for
  global initializations, the size of a function pointer can not be encoded.
     Example:
  void near f(void);
  void (*near ptr_to_f)(void) = f;
  void far g(void);
  void (*far ptr_to_g)(void) = g;

- The compiler now shows the waiting cursor during a compilation.
  Note that the waiting cursor only occurs when the mouse is over the open compiler
  window. Otherwise the mouse is not changed. Version 2.7 tools instead do always
  change the mouse cursor.
- The question when the current editor that was not setup correctly does now only
  appear when the compiler is started without any command line arguments.
- The toolbar does contain an additional button to clear the log.
- New options -WmsgFoi and -WmsgFob to specify message format for batch and
  interactive format. These options are using a format string for a flexible message
  format.
- The compiler tries to use integral compares instead double compares now
  whenever possible. This reduces usage of runtime libraries and increases code
  speed. The option -Ont may be used to switch this optimization off.
- The compiler tries to use integral compares instead double compares now
  whenever possible. This reduces usage of runtime libraries and increases code
  speed. The option -Ont may be used to switch this optimization off.
- The -Ont option does have now suboptions to disable single optimizations.
- C++ library "complex" for complex arithmetic.
- The new option -PEDIV allows selective enabling of the use of the EDIV HC12
  instruction. This instruction was generated by compiler version 5.0.10 whenever
  applicable.
  In the computation of 100008 % 10 the hardware does not return 8 as result
  because in the quotient does not fit into 16 bit. The new compiler uses for a 32 bit
  modulo 16 bit giving 16-bit division the EDIV instruction only when the option -
  PEDIV was given.
- Inline assembler code can now access local variables with a offset larger than the
  object. The message C10030, which is emitted in this situation, can now be
  disabled.
- the HICROSS +compilers do now also support the directory searching feature for
  environment variables.
  The compiler finds include files included with <> (#include <test.h>) in the
  directory c:\hicross\work and all its subdirectory and in the directory c:\hicross\lib
  with the following entry in default.env :
     LIBPATH=*c:\hicross\work;c:\hicross\lib
- The "-oc" common subexpression optimization was removed from the compiler.
  The other common subexpression elimination "-one" does cover much more cases
  and produces better code. There were only very few situations -oc did improve the
  code compared with "-one". Also "-oc" did have some weaknesses in recognizing
  all alias effects. For this version, "-oc" is still present in the option list to be
  compatible. However, this option has no effect at all. In future versions, "-oc" may
  be completely removed.

List of fixed Bugs
- Previous versions did allocate a global variable as loop counter even when the loop
  body does contain functions in some cases.
  Note that when using loop-unrolling -cu, this optimization may still be done.
     Example:
     int i;
     void f(void);
     void main(
       for (i=0; i < 100; i++) {
         f();
       }
     }
     void f(void) {
       i = 200;
     }
- If no messages are generated, an empty error/message file is generated now.
  Previously there was no error file if the compiler did not issue a message. This
  caused problems with the CodeWright editor, which expects always a message file,
  even if there are no messages.
- Referencing an array-type member of a struct at constant address generates now
  correct code.
  Example:
     struct A {
       struct {
         char buf[2];
       } ar[4];
     };
     char ch;
     void main() {
       ch=(char)(&((struct A*)0x00)->ar[1]);
     }
- C++ Constructor call at "new" operator call with array of inherited class assigned to a pointer to base class.
   Example:
   class A {
     A();
   };
   class B : A {
     B();
   };
   void f(void) {
     A *a = new B[5];// now generating correct Constructor calls!
   }
- Inline assembler accesses to local variable did use a false offset when static spills
  were present in this function.
- Inline assembler can now access variables with an offset larger than their size.
  Previous versions did issue an error in this case. This version only emits a warning.
     Example:
     void main(void) {
       int i;
       asm LDD i:20;
     }
- Open parameters calls with one single actual parameter, which was used
  afterwards, were in some special situation not correctly treated. During the
  function call, push /pop spills were generated although already the parameter has
  been pushed.
- Accesses to large far data objects were encoded incorrectly. The object offset was
  added in some circumstances to the page and not only to the 16 bit offset.
- In some circumstances a illegal MOVB/MOVW instruction could have been
  generated. In this situation the compiler did emit a Unknown Operand
  Combination error and did not generate any code.
- Inline assembler code can now access local variables with a offset larger than the
  object. The message C10030 which is emitted in this situation can now be
  disabled.
- The runtime routines _LCMP_P/_LCMP_P for indirect long compares did not
  correctly set the carry flag.
- The double (IEEE64 only) to long conversion runtime routine D_TOLONGK did
  not correctly treat very large values close to MAX_LONG.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object
  file format). The startup code do not support calling destructor functions.
     class A {
       int m;
       ~A();
     };
     A a;     // not calling destructor at end of program
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- Declare Constant Byte in inline assembler containing a variables name does not
  work, 2 bytes are allocated instead.
- Example:
   char a;
   DC.B a     ; allocates 2 bytes instead one
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
- [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
- Register trace does not care about registers used in HLI blocks:
- Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the
  HLI assembly block.
     Workaround:
     Always save the register you are using at the beginning of an HLI assembly block and
  restore them at the end of the block.
     The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf ,switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
     WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The option -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info do not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
- Register parameter does not generate debug info, when it is not allocated on the
  stack. Note that even when it is stored with a PUSH, it is not clear if it is allocated
  on the stack. The PUSH may also be generated by a spill. This situation often
  occurs in small C++ member functions, where only the this pointer is passed and
  the this pointer is directly used.
- Some very special cases of 16 or 8 bit assignments can generate the message :
   ERROR: C12020: Unknown Operand Combination: Opr1:Imm16/Opr2:IdxInd16.
   Example :

   typedef struct {
   int i;
   } A;
   A ** ppa ;

   void main(A** ppa2) {
   ppa= ppa2;
   * ppa = ( ( A* ) 0 );
   ppa = ppa2 + 1 ;
   }

   This bug can only appear in the following situation :
   - On the left side of a assignment is a pointer indirection.
   - The value to be assigned is 8 or 16 bits large.
   - The value to be assigned is 0.
   - Even when this conditions are satisfied, this bug only happens in other special
  situations.
  The compiler does not generate a object file if this bug appears. Please reformulate
  the specific assignment.


RELEASE NOTES CHC12 V5.0.10
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
  NOTE: Recompile all your sources

List of new Features
- Bitfields inside unions are legal
   Example:
   struct {
     union {
       char ch : 1;  // legal !
     } u;
   } S;
- New options -CswMinLF, -CswMaxLF, -CswMinLB to configure switch
  processor behavior (HICROSS+ only), see manual for details.
- New macro __VERSION__ to identify compiler version. E.g. for a compiler
  V5.0.2 the value of the macro is 5002, for a compiler with version V3.0.17 it is
  3017.
- The number of pragmas active at the same time is no longer artificially limited.
- The new pragma MESSAGE can be used to set messages to a certain kind. E.g. to
  set the message 'Implicit Function Definition' to an error.
- The new pragma OPTION can be used to enable certain options for some functions
  only. E.g. to enable -cni during one time critical function.
- characters with ACSII code larger than 0x7f were treated from previous compiler
  versions as white space characters (like a space). This compiler version no emits an
  error.
- The new pragma STRING_SEG or STRING_SECTION allows the allocation of
  all following strings into a specific segment. Strings put into a named segment are
  handled by the linker like constants. The string segment pragma must also contain
  modifiers like "DPAGE", "SHORT" as any other segment pragmas if the strings
  are allocated in a non default way.
  Examples:
     #pragma STRING_SEG MY_STRINGS
     void main(void) {
       printf("Print %s", "Print");
     }

     char* str="str";

     #pragma STRING_SEG DPAGE MY_FAR_STRINGS
     void f(char* far str);
     char ch;
     void main2(void) {
       f("Test");
       ch= "Test2"[2];
     }
     #pragma STRING_SEG DEFAULT
- The strings "Print %s", "Print" and "str" are allocated in the segment
  MY_STRINGS.
- The strings "Test" and "Test2" are allocated in the segment MY_FAR_STRINGS.
  Accesses to Test and Test2 are done by setting the DPAGE registers.
- So ch will contain an 's' even if MY_FAR_STRINGS is allocated on page 13.
- Note that usual string pointers of type "char *" are only 16 bits wide. To access a
  string on a far page, a far string pointer of type "char *far" must be used.
- Calling the standard libraries (printf, strlen,...) with far strings does not work, as
  the libraries only work with usual "char*" string pointers and not with far string
  pointers.

List of fixed Bugs
- Message output format in Microsoft had an additional ':' after the message kind
  (file(line): ERROR: C1234: message). The output format has now changed back
  to 'file(line): ERROR C1234: message.
- struct copy of objects from or to far data areas did sometimes go wrong when the
  loop counter was invalidated through a spill.
        This bug could occur in the following cases:
    - a object with at least 6 bytes have to be copied
    - either the source or the destination is in the far data area
    - either the destination or the source pointer was reused afterwards in a linear
  code sequence.
- Arrays first defined and then declared did not work correctly.
  With the ELF object file format, a compiler internal error in the elf.c module was
  reported. In the HIWARE object file format, the object was only declared, but not
  defined, so the linker did issue a error message.
  Example:
     char a??="Example";
     extern char a??;
  - This bug did occur only in the following cases :
  -  - first a definition and then a declaration (reverse order of the usual case)
  -  - only for arrays
  -  - array was declared without the array size (not in the form "extern char a?8?;")
  - The inline assembler did not correctly set fixups for MOVB and MOVW
  instructions in the EXT/IDX addressing modes.
  Example
     int var;
     void main(void) {
       asm MOVB var,0,X
     }
     The fixup for var was put at the wrong address.
     This bug did occur only in the following cases :
      - MOVB and MOVW assembler instructions.
      - the first operand uses EXT addressing mode
      - the first operand has a fixup on it
      - the second operand is one of the IDX addressing modes

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object
  file format). The startup code do not support calling destructor functions.
     class A {
       int m;
       ~A();
     };
     A a;     // not calling destructor at end of program
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- Declare Constant Byte in inline assembler containing a variables name does not
  work, 2 bytes are allocated instead.
- Example:
   char a;
   DC.B a     ; allocates 2 bytes instead one
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to
  itself.
- Be careful with -Oc and aliases:
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
- [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
- Register trace does not care about registers used in HLI blocks:
- Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the
  HLI assembly block.
     Workaround:
     Always save the register you are using at the beginning of an HLI assembly block and
  restore them at the end of the block.
     The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf ,switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
     WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The option -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info do not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
- Register parameter does not generate debug info, when it is not allocated on the
  stack. Note that even when it is stored with a PUSH, it is not clear if it is allocated
  on the stack. The PUSH may also be generated by a spill. This situation often
  occurs in small C++ member functions, where only the this pointer is passed and
  the this pointer is directly used.
- Some very special cases of 16 or 8 bit assignments can generate the message :
     ERROR: C12020: Unknown Operand Combination: Opr1:Imm16/Opr2:IdxInd16.
     Example :

     typedef struct {
     int i;
     } A;
     A ** ppa ;

     void main(A** ppa2) {
     ppa= ppa2;
     * ppa = ( ( A* ) 0 );
     ppa = ppa2 + 1 ;
     }

     This bug can only appear in the following situation :
     - On the left side of a assignment is a pointer indirection.
     - The value to be assigned is 8 or 16 bits large.
     - The value to be assigned is 0.
     - Even when this conditions are satisfied, this bug only happens in other special
  situations.
  The compiler does not generate a object file if this bug appears. Please reformulate
  the specific assignment.


RELEASE NOTES CHC12 V5.0.09
   Note: These Release Notes contain some information about the C++ Compiler. If your
   license configuration does not include the C++ feature, just ignore all topics related to C++.
   NOTE: Recompile all your sources

List of new Features
- Functions containing function calls and/or loops inside can now be inlined, too !
- The option -px4 is no longer used to build the library. So the HC12 instructions
  TBNE, IBNE and similar are now used to build the library. An early version of the
  HC12 did not correct handle this instructions, so if you need a library without these
  instructions either build the library with option -px4 yourself or contact HIWARE to
  get a special version built with option -px4.
- Global variable address modifier
   Global variables can be put to specific addresses with the global variable address
  modifier. It has following syntax:
     Declaration =
   <TypeSpec><Declarator>[@ <Address>][=<Initializer>];
      Example:
   int glob @0xff02;  // variable "glob" lies at 0xff02
- New option -Wmsg8x3 (PC only): This option truncates the file names in the message
  log file to the MS-DOS format (8.3 format). E.g. if this option is set and the source file
  is named 'mysourcefile.c', the source file referenced in the message output is
  'mysource.c'. This was the default behavior in earlier versions, because some editors
  (e.g. very old versions of WinEdit) do have problems with file names larger than 8.3
  format. The default is not to truncate the source file name in the message output.
- New option -ObjN to specify the object file name, default is "-ObjN=%n.o". This
  option allows changing the default object file name which is normally the source file
  name with extension ".o". E.g. to specify the extension ".obj" for the object files
  generated by the compiler, the option "-ObjN=%n.obj" may be specified (see manual
  for details).
- The option to specify the virtual table delta size (-Tvtd, see manual for details (option -
  T)). Previously the delta value inside the virtual tables was of type 'size_t', but now it
  is possible to specify a smaller (or larger) type using the option -T. Using virtual
  member functions, virtual function tables are generated. Those tables contain a
  function pointer and an associated delta value used to access the base class. Usually
  those delta values do have a (signed) 16bit type, allowing class objects with a size of
  32kByte each. But to save ROM usage for such tables, the type of this delta value can
  be changed using the -Tvtd option. E.g. if all class objects are smaller or equal 127
  bytes, then the virtual table delta type can be changed to a 1 bytes (signed!) type using
  -Tvtd. If there should be a class object not fitting into this type, an error message
  (C1393) will be generated.
- The TreeOptimizer (option -Ont to switch it off) warns now about removed labeled
  statements. Example:
       switch(i) {
         Label: ... // Labeled statement removed
  The TreeOptimizer (option -Ont to switch it off) does also optimize modulo operations
  with a constant on unsigned characters.
       Example:
     uch = uch % 16;  // optimized to 'uch = uch & 0xF;'
- If the environment variable OBJPATH is used, but the compiler is not able to create
  the object file in this path (e.g. because an already existing object file is locked by
  another tool, to compiler issues now an error message instead trying to create the
  object file in the path where the source has been found.
- If the Compiler is started with arguments (e.g. using a make file), the compiler does
  not grab the focus and is also visible in the task bar.
  New option -Qvtp to specify the qualifier for virtual table pointers (C++ only, see
  Manual for details)
  defines for size_t and ptrdiff_t has been moved from stddef.h to stdtypes.h, stddef.h
  includes now stdtypes.h
  The defines '__SIZE_T_IS_USHORT__' and '__PTRDIFF_T_IS_SHORT__' are now
  available.
- It is now possible to use empty blocks in HLI. This is useful using conditional
  compilation which may result in empty blocks.
     Example:
     asm {
     #if 0
       /* something commented out */
     #endif
     }
- C++ References can be qualified
        Example:
     int j;
     void main(void) {
       int &far i = j;  // "far" qualifier for reference
     }
- C++ static template member initialization
   Example:
   template <int i> struct S {
     static char A;
   };
   template <int i> char S<i>::A; // init static member
   S<3> s;
- C++ sets global constant objects to have static linkage per default
      Example:
   const int j = 0;     // j has static linkage
   extern const int i;     // i has extern linkage
- C++ does not allow initialization of array with too long string
      Example:
   char str[3]="abc";  // error, "abc" has length 4
- cC++ language configuration
   New options for C++ support (also configurable by the option dialogbox):
   -C++f: Full C++ support
   -C++e: Embedded C++ support (EC++)
   -C++c: Compact C++ support (cC++)
- New options for enabling/disabling cC++ features (also configurable by the option
  dialogbox):
   -Cn=Ctr: Do not create compiler defined functions
   -Cn=Vf: Do not allow virtual functions
   -Cn=Mih: Do not allow multiple inheritance and virtual base classes
   -Cn=Tpl: Do not allow templates
   -Cn=Cpr: Do not allow class params and class returns
   -Cn=Ptm: Do not allow pointer to member
   Note: The option -C++ does not exist anymore !
- Local static variables can now be qualified, too !
      Example:
   void f() {
      static int far i;
   }
- Treeopt: Expansion of long compares into 2 or 3 int compares.
  To avoid time consuming runtime calls for a long compare the compiler now expands
  a long compare into 2 (==, !=) or 3(>, >=, <, <=) int compares, which can be inlined. If
  the code size increases, the expansion is only done if the option -ot is given.
  Usage of extended integer multiplication and -division instructions (EMUL(S),
  EDIV(S)). Expensive runtime calls to long routines are avoided for following
  situations:
- EMUL(S) is used for long l = (long)i * (long)j, if i and j are both signed or unsigned
  integers, instead of JSR _LMUL(S).
- EDIV(S) is used for int i = l / j or i = l % j, if i and j are both integers and l is a long,
  instead of JSR _LDIV(S).
  The compiler now warns for (maybe) undefined local variables.
     Example:
     int f(void) {
     int I;
     return I;
  }

List of fixed Bugs
- Odocf Problem: when starting the compiler from the command line or from the maker, the
  -odocf was ignored until now when the double quotes (") were not escaped. E.g.
  compiler.exe b.c -odocf="-or" did never use -or. The reason is that command.com does
  only forward the following to the compiler: 'compiler.exe b.c -odocf=-or' And -
  odocf=-or was ignored. Now this is an error. Especially all makefiles using odocf will
  no work until the double quotes were escaped correctly. E.g. compiler.exe b.c -
  odocf=\"-or\"
- Indirection of address of constant variable is a lvalue !
      Example:
      const int i;
      void f(void) {
         *(int *)&i=2;  // legal !!
      }
- in the startup header file "start12.h" in the banked memory model, the segment pragma
  #pragma CODE_SEG NEAR NON_BANKED
  was active at the end.
  Now the default code segment is set instead.
- The Y register was not correctly marked as invalid at JSR and CALL instructions with
  a register indirect access to the function pointer. Example
     struct A {
       void (*f)(void);
       void (*g)(void);
       int i;
     };

     A a;
     void f (void) {
       struct A* p=a;
       p->f();
       p->g(); /* p was not reloaded */
     }
- If there was a byte copy from an array in extended addressing space to an array in the zero
  page using an index variable, wrong relocation type was used: fixed. Example:
   #pragma DATA_SEG SHORT
   char a[3];
   #pragma DATA_SEG DEFAULT
   char b[3];
   a[i] =  b[i]; // was wrong relocation
- If a path with slashes (/) was used on a PC, the file name was truncated in the error
  feedback, e.g. for '../src/foo.c' the message line was '../src.c(3) ...'
- TreeOptimizer did a sign extension instead a zero extension for the following example
  (workaround was to specify -Ont as compiler option):
     int i; int j;
     i = (i+j)&0xff;
  improved precision for strtod()
- C++ labeled statements with new/delete operator calls: Generated code now correct !
      Example:
      void f(int i) {
         int a;
         switch(i) {
            case i:
               a = new int; // did produce wrong code
               break;
         }
      }
- C++ declaration of friend function with default argument in class declaration are now
  producing correct code !
      Example:
      struct A {
        friend void f(int i=0); // did produce wrong code
      };
- C++ argument of function call is a function call returning inherited class is legal !
      Example:
   struct A {
     int i;
   };
   struct B : public A {
   };

   void F(A);
   B g(void);

   void main(void) {
     F(g());   // didn't compile in previous versions
   }
- C++ assignment operator overloading should also be done for initialization assign
      Example:
   struct A {
     A &operator=(int i);
   };

   void main(void) {
     A a = 3;  // call of assignment operator
   }
- C++ initialization of open array of class objects with Ctor argument
   struct A {
     A(char *);
   };

   void main(void) {
     A a[] = {"Hello"};      // now ok !!
   }
- Correction about undefined enums.
      Example:
   enum E e;  // now legal !

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object
  file format). The startup code do not support calling destructor functions.
   class A {
     int m;
     ~A();
   };
   A a;     // not calling destructor at end of program
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
     Declare Constant Byte in inline assembler containing a variables name does not work,
  2 bytes are allocated instead.
        Example:
     char a;
     DC.B a     ; allocates 2 bytes instead one
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to
  itself.
- Be careful with -Oc and aliases:
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
        [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
- Register trace does not care about registers used in HLI blocks:
  Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the
  HLI assembly block.
     Workaround:
  Always save the register you are using at the beginning of an HLI assembly block
  and restore them at the end of the block.
- The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf ,switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The option -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info do not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
- Register parameter does not generate debug info, when it is not allocated on the
  stack. Note that even when it is stored with a PUSH, it is not clear if it is allocated
  on the stack. The PUSH may also be generated by a spill. This situation often
  occurs in small C++ member functions, where only the this pointer is passed and
  the this pointer is directly used.


RELEASE NOTES CHC12 V5.0.08
  Note: These Release Notes contain some information about the C++ Compiler. If your
  license configuration does not include the C++ feature, just ignore all topics related to C++.
   NOTE: Recompile all your sources

List of new Features
- New options for Object File Handling:
  -Fh: HIWARE Object File Format (Default)
  -F7: strict HIWARE Object File Format
  Using the strict HIWARE V2.7 Object File Format provides full compatibility with
  the HI-CROSS V2.7 Object File Format. Using the option -F7 affects the object
  files in the following points:
- The standard type 'short' is written as 'int' into the object file
- Enumerations are not written symbolically into the object file
- The option -Fsi (treat short as int in the object file format), this is included now in
  the option -F7
- New tree optimizations (-Ont to switch it off):
- Optimization of EXOR with constants in comparisons with constants (== or !=).
  Such code sequences are common in bitfield operations.
        Example:
     unsigned char uc;

     if ((uc^3) != 2) ...
     // optimized to:
     // (uc != 1)
- New tree optimizations (-Ont to switch it off):
  Optimization of '?' operations. Such code sequences are common in bitfield
  operations.
        Example:
     unsigned char uc;
     uc = (uc&1)?-1:0;
     // optimized to:
     // uc = uc?1:0;
- The loop unrolling option now has an argument to specify the maximum loop
  unrolling iteration level. The syntax is '"-Cu" [ "=i"<number>]' where number can
  be between 0 and 1024. Without any additional arguments, loop unrolling is
  performed until a maximum of 15 iterations, e.g. 'for(i=0; i<15; i++)...'. To unroll
  larger loops, the additional argument can be used, e.g. with '-Cu=i100' loops until
  100 iterations are unrolled.
- New option to change enum type to a signed or unsigned type (e.g. -Tue1 to set
  enumeration to one unsigned type), see manual for details. Note that in the
  previous version the command line option -Tue1 was also accepted, but in fact it
  was the same behavior than -Tuce1.
- C++ default arguments
- C++ global operator overloading
   class A {
      /* ... */
   } a;
   int operator+(A a, int i);
   void f() {
      int i=a+43;
   }
- C++ conversion operator overloading
   struct A {
      operator int();
      /* ... */
   } a;
   void f() {
      int i=a;
   }
- The -D option does not use any more temporary files
- fabs and fabsf are now performed inline if -Ot (Optimize for time) is given
- New Tree Optimizer (-Ont to switch it off):
  Warning about assignment in conditions for the 'for' condition
     Example:
     if (i = 0)    // warning
  Tests on IEEE32 floating values now optimized in the front end:
     Example:
     if (floatVar >= 0)    // optimized to sign test
     if (floatVar == 0.0F) // optimized to a 32bit compare
     if (floatVar != 3.0F) // optimized to a 32bit compare
  Multiplication with one is now optimized in the front end:
     Example:
     i = j * 1;  // optimized to i = j;
  Multiplication with zero is now optimized in the front end:
     Example:
     i = j * 0;  // optimized to i = 0;
  Division operations are optimized in the front end:
     Example:
     i = j / 1;  // optimized to i = j;
     i = j / j;  // optimized to i = 1;
  Subtraction with zero now optimized in the front end:
     Example:
     i = j - (j-j);  // optimized to i = j;
     Addition with same left and right expression is now optimized in the front end:
     Example:
     i = j + j;  // optimized to i = j << 1;
  Binary AND operations are now optimized in the front end:
     Example:
     i = j & 0;  // optimized to i = 0;
     i = j & j;  // optimized to i = j;
  EXOR operations are now optimized in the front end:
     Example:
     i = j ^ 0;  // optimized to i = j;
     i = j ^ j;  // optimized to i = 0;
  Constant switch expressions are now optimized:
     Example:
     switch(3)
       case 1: j = 1; break;
       case 3: i = 0; break;
     is optimized to
     i = 0;
     Constant narrowing is now performed on front end level:
     Examples:
     if (uc1 == 0x111) /* always false */
     if (uc1 <= 0x111) /* always true */
- New option -Oilib=<char>. This option enables inlining specific library functions
  to reduce execution time significantly.
  Currently inlined functions are:
     strcpy   option: -Oilib=a
- New Backend optimization for Common Code. Identical code patterns are
  searched and replaced by a JSR to a new location, where the patters is placed only
  once. At the end a RTS instruction is added. This optimization may produce
  problematic debug info. To switch it off, use -onf. When optimizing for
  compilation time -ot, it is switched of by default.
- New defines __PRODUCT_HICROSS__, __PRODUCT_HICROSS_PLUS__ and
  __PRODUCT_SMILE_LINE__ to identify the product line

List of fixed Bugs
- C++ order of function calls in Constructor of inherited class
   class myclass1 {
     private:
     int private_member;
     public:
     myclass1( )  {  private_member = 9;  }    // constructor
     int  method1( int x )  {  return  x+private_member;  }
   };

   class myclass2 : public myclass1 {
     public:
     myclass2() : myclass1( )  {   // constructor
            // method1(16) should return 25
            // instead "uninitialized private_member value" + 16
       int x = method1(16);
       if ( x != 25 ) {Error;}
     }
   };
- C++ Enum inside inherited classes
   Example:
   class A {
     typedef enum {myenum=11};
   };

   class B : public A {
     int f(void);
     typedef enum {myenum=22};
   };

   int second::f() {
     return myenum;  // returns B::myenum
   }
- C++ does not allow to overload member delete operators
  Example:
     class A {
       void operator delete(void *);
       void operator delete(void *, unsigned int);   // error
     };
- bug report cnibuffr.cpp (trane company)
- It was not possible to specify more than one of the -MsgSx options: fixed
- The standard predefined macro for C++ has changed from 'cplusplus__' to
  '__cplusplus'.
- It is not possible to specify zero bytes inside character strings, e.g. "a\0_abc".
- The preprocessor can now have the "defined" keyword not only in #if, but also in
  #define
     Example:
     #define A
     #define B defined(A)
     #if B
     /* compiled code */
     #endif
- C++ implicit casting to base class pointer for call of operator "new"
      Example:
   class A {};
   class B : A {};
   void f() {
     A *a = new B;
   }
- No warning for assigning a pointer to a pointer to const void.
      Example:
   void f(const void *);
   const unsigned char cp[3];
   void main() {
     f(&cp[0]);
   }
- setjmp/longjmp does work in banked memory model
- The following warning was issued in previous compiler version sometimes:
- WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- It was caused by a implementation of the debug info generation which did not
  consider the control flow. It does not indicate wrong code.
- The reason for this message occurring until now has been fixed, but the new
  common code optimization -of/-onf generates new situation, where no correct
  debug info can be generated. So this message does still occur in this situation. Use
  -onf to switch of the optimization.
- When using the option -or, the compiler did generate sometimes strange code
  before a branch or a place where other code branches to.
  The code generating this code has been rewritten and is now part of the peephole
  optimizer. Use the new suboption -OnP=q to switch is off.
  Note the code of the previous version was too large, but is was correct. Actually
  the option -or does generate often for large functions more code than not using -or.
  To archive best results, use -or together with -odocf (-odocf="-or"), only available
  for HICROSS +.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object
  file format). The startup code do not support calling destructor functions.
     class A {
       int m;
       ~A();
     };
     A a;     // not calling destructor at end of program
- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- C++ templates not fully working according ANSI standard.
- Declare Constant Byte in inline assembler containing a variables name does not
  work, 2 bytes are allocated instead.
  Example:
     char a;
     DC.B a     ; allocates 2 bytes instead one
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to
  itself.
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
        [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
- Be careful with -Oc and aliases:
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to
  itself.
- Register trace does not care about registers used in HLI blocks:
     Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the
  HLI assembly block.
        Workaround:
     Always save the register you are using at the beginning of an HLI assembly block
  and restore them at the end of the block.
  The SP debug info can not be generated consistently with the common code
  optimization (option -of/-onf ,switched on by default) in all cases.
  This is a conceptual problem and not a bug of the current implementation. An
  example of such a situation is given in the current manual and in the help file.
  To avoid this situation switch of the common code optimization with -Onf.
  The following warning is issued when this situation occurs:
  WARNING C12056: SP debug info incorrect because of optimization or inline
  assembler
- The option -Or and -Ol do not generate full debug info.
  With register optimization -or, all variables located in registers do not have debug
  info. To get correct debug info do not use -or.
  With the induction variable optimization -ol, variables (also globals) which are
  allocated temporarily in registers do not have correct debug info during the period
  they are in registers (mainly small loops). Induction variables are switched on by
  default, so use -ol0 to generate correct debug info.
- Register parameter does not generate debug info, when it is not allocated on the
  stack. Note that even when it is stored with a PUSH, it is not clear if it is allocated
  on the stack. The PUSH may also be generated by a spill. This situation often
  occurs in small C++ member functions, where only the this pointer is passed and
  the this pointer is directly used.


RELEASE NOTES CHC12 V5.0.07
   NOTE: Recompile all your sources

List of new Features
- C++ default arguments
- C++ global operator overloading
   class A {
      /* ... */
   } a;
   int operator+(A a, int i);
   void f() {
      int i=a+43;
   }
- C++ conversion operator overloading
   struct A {
      operator int();
      /* ... */
   } a;
   void f() {
      int i=a;
   }
- The -D option does not use any more temporary files
- fabs and fabsf are now performed inline if -Ot (Optimize for time) is given
- New Tree Optimizer (-Ont to switch it off):
     Warning about assignment in conditions for the 'for' condition
     Example:
     if (i = 0)    // warning
  Tests on IEEE32 floating values now optimized in the front end:
     Example:
     if (floatVar >= 0)    // optimized to sign test
     if (floatVar == 0.0F) // optimized to a 32bit compare
     if (floatVar != 3.0F) // optimized to a 32bit compare
  Multiplication with one is now optimized in the front end:
     Example:
     i = j * 1;  // optimized to i = j;
  Multiplication with zero is now optimized in the front end:
     Example:
     i = j * 0;  // optimized to i = 0;
  Division operations are optimized in the front end:
     Example:
     i = j / 1;  // optimized to i = j;
     i = j / j;  // optimized to i = 1;
  Subtraction with zero now optimized in the front end:
     Example:
     i = j - (j-j);  // optimized to i = j;
  Addition with same left and right expression is now optimized in the front end:
     Example:
     i = j + j;  // optimized to i = j << 1;
  Binary AND operations are now optimized in the front end:
     Example:
     i = j & 0;  // optimized to i = 0;
     i = j & j;  // optimized to i = j;
  EXOR operations are now optimized in the front end:
     Example:
     i = j ^ 0;  // optimized to i = j;
     i = j ^ j;  // optimized to i = 0;
  Constant switch expressions are now optimized:
     Example:
     switch(3)
       case 1: j = 1; break;
       case 3: i = 0; break;
     is optimized to
     i = 0;
  Constant narrowing is now performed on front end level:
     Examples:
     if (uc1 == 0x111) /* always false */
     if (uc1 <= 0x111) /* always true */
- New defines __PRODUCT_HICROSS__, __PRODUCT_HICROSS_PLUS__ and
  __PRODUCT_SMILE_LINE__ to identify the product line

List of fixed Bugs
- bug report cnibuffr.cpp (trane company)
- It was not possible to specify more than one of the -MsgSx options: fixed
- The standard predefined macro for C++ has changed from 'cplusplus__' to
  '__cplusplus'.
- It is not possible to specify zero bytes inside character strings, e.g. "a\0_abc".
- The preprocessor can now have the "defined" keyword not only in #if, but also in
  #define
        Example:
     #define A
     #define B defined(A)
     #if B
     /* compiled code */
     #endif

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object file
  format). The startup code do not support calling destructor functions.
     class A {
        int m;
        ~A();
     };
     A a;     // not calling destructor at end of program

- The ROM libraries are not initialized. This includes the zero out and copy down of
  global variables. C++ Constructor and Destructor calls are not done for ROM
  libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- C++ templates not fully working according ANSI standard.
- Declare Constant Byte with variables does not work, 2 bytes are allocated instead.
  Example:
     char a;
     DC.B a     ; allocates 2 bytes instead one
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to
  itself.
- Incorrect code is generated for following code:
        Example:
     char *p;
     *p++ |= 3;  /* set bit 1 && 3 */
     This bug occurs with all opassigns (*=, +=, ....) when the left side contains side
  effects. The side effect occurs twice instead of one time as defined by the ANSI
  standard.
        Workaround:
     char *p;
     *p |= 3;  /* set bit #1 && 3 */
     *p++;
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
        [Note: The -OdocF option (OptiHunter(tm)) is only available with a special
  license].
- Be careful with -Oc and aliases:
  The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
  Register trace does not care about registers used in HLI blocks:
     Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the
  HLI assembly block.
        Workaround:
        Always save the register you are using at the beginning of an HLI assembly block
  and restore them at the end of the block.

Libraries
- setjmp/longjmp does not work in banked memory model


RELEASE NOTES CHC12 V5.0.06
   NOTE: Recompile all your sources

List of new Features
- New MCUTOOLS.INI: All tools store now their global information instead in the
  HICROSS.INI file in the windows directory in a file called MCUTOOLS.INI. Below a
  short extract from the manual:
     MCUTOOLS.INI File (PC only)
     All tools may store some global data into the MCUTOOLS.INI. The tool first
  search for this file in the directory of the tool itself (path of the executable). If
  there is no MCUTOOLS.INI file in this directory, the tool looks for a
  MCUTOOLS.INI file located in the MS Windows installation directory (e.g.
  C:\WINDOS).
     Example:
     C:\WINDOWS\MCUTOOLS.INI
     D:\INSTALL\PROG\MCUTOOLS.INI
     If a tool is started in the D:\INSTALL\PROG\DIRECTOY, the project file in the
  same directory than the tool is used (D:\INSTALL\PROG\MCUTOOLS.INI).
     But if the tool is started outside the D:\INSTALL\PROG directory, the project
  file in the Windows directory is used (C:\WINDOWS\MCUTOOLS.INI).
     The HICROSS.INI file is not used any more. It can be renamed to MCUTOOLS.INI,
  because the format remains the same.
  Compiler switches -WmsgFiv, -WmsgFim, -WmsgFbv, -WmsgFbm (HICROSS+
  only):
- It is now possible to select the message output format for the batch (compiler window
  is not visible, e.g. started from WinEdit with modifier %f or from the Make tool) and
  interactive (compiler window is visible) mode of the compiler:
     -WmsgFiv: Set message format in interactive mode to verbose (default)
     -WmsgFim: Set message format in interactive mode to Microsoft
     -WmsgFbv: Set message format in batch mode to verbose
     -WmsgFbm: Set message format in batch mode to Microsoft (default)
     Setting the message format in the interactive mode to Microsoft format will speed up
  the compilation, because less information has to be printed.
- Compiler switch -Fsi: Treat short as int in HIWARE object file format
  Previous versions of the Compiler did not write the 'short' type correctly into the HI-
  CROSS object files, they were written as 'int' to the object file. The result was that the
  variables with type 'short' were displayed with type 'int' in the simulator/debuggers.
  The actual compiler handles the 'short' type in the HI-CROSS object file format
  correctly now, but older versions of debugger/simulators/emulators may have now a
  problem if there is a 'short' type now in the object file (e.g. older HI-CROSS
  simulator/debuggers may display it as a 'SET' type with unknown members.
  The actual versions of simulators/debuggers do not have this problem, but if there are
  problems, the old behavior can be forced with the compiler switch -Fsi.
- Multiplication with one is now optimized in the front end:
      Example:
   i = j * 1;  // optimized to i = j;
- Multiplication with zero is now optimized in the front end:
      Example:
   i = j * 0;  // optimized to i = 0;
- Division operations are optimized in the front end:
      Example:
   i = j / 1;  // optimized to i = j;
   i = j / j;  // optimized to i = 1;
- Subtraction with zero now optimized in the front end:
      Example:
   i = j - (j-j);  // optimized to i = j;
- Addition with same left and right expression is now optimized in the front end:
      Example:
   i = j + j;  // optimized to i = j << 1;
- Binary AND operations are now optimized in the front end:
      Example:
   i = j & 0;  // optimized to i = 0;
   i = j & j;  // optimized to i = j;
- EXOR operations are now optimized in the front end:
      Example:
   i = j ^ 0;  // optimized to i = j;
   i = j ^ j;  // optimized to i = 0
- Long shifts with 8 are inlined instead of calling a runtime routine. This is much faster.
  The code size remains the same for left shifts and is smaller for right shifts.
- Always the HC12 instruction EMUL is used for multiplication of 16 bit unsigned
  integers because EMULS is 1 byte larger in size.
- If the compiler option -ot (optimize for time) is given, 16 to 32 bit sign extensions are
  inlined to increase the execution speed.
      Example: (for the last 3 points)

   long x;
   int i;

   void main(void) {
     x = (long)(i*i) << 8;
   }

   CHC12 V5.0.6
   ------------

   00000000 FC0000       LDD   i
   00000003 B746         TFR   D,Y
   00000005 1813         EMULS
   00000007 160000       JSR   _ILSEXT
   0000000A B746         TFR   D,Y
   0000000C C608         LDAB  #8
   0000000E 160000       JSR   _LSHL        ; call to runtime routine
   00000011 7C0000       STD   x:2
   00000014 7E0000       STX   x

   Code Size: 23 bytes
   Execution Time: 158 Cycles

   CHC12 V5.0.7
   ------------

   00000000 FC0000       LDD   i
   00000003 B746         TFR   D,Y
   00000005 13           EMUL                 ; unsigned multiplication
   00000006 160000       JSR   _ILSEXT
   00000009 B7D4         EXG   X,D            ;
   0000000B 34           PSHX                 ; always inline implementation
   0000000C 37           PSHB
   0000000D 30           PULX
   0000000E 32           PULA
   0000000F C7           CLRB
   00000010 7C0000       STD   x:2
   00000013 7E0000       STX   x

   Code Size: 22 bytes
   Execution Time: 44 Cycles

   CHC12 V5.0.7
   ------------

   Option -ot (optimize for time)

   00000000 FC0000       LDD   i
   00000003 B746         TFR   D,Y
   00000005 13           EMUL
   00000006 3B           PSHD                 ; sign extension done inlinely
   00000007 B704         SEX   A,D
   00000009 B705         SEX   A,X
   0000000B 3A           PULD
   0000000C B7D4         EXG   X,D
   0000000E 34           PSHX
   0000000F 37           PSHB
   00000010 30           PULX
   00000011 32           PULA
   00000012 C7           CLRB
   00000013 7C0000       STD   x:2
   00000016 7E0000       STX   x

   Code Size: 25 bytes
   Execution Time: 33 Cycles

List of fixed Bugs
- The V5.0 Compiler has generated started with arguments (e.g. using WinEdit and the %f
  in the Project Configure Dialog) the HIWARE Error List File Format in the EDOUT
  file instead the Microsoft Error File Format. This caused the WinEdit Editor do
  display only the first compilation error.
- The Compiler generates now the Microsoft Error File Format in the EDOUT error file
  requested by WinEdit.
   Note: Some WinEdit Versions have problems to locate the EDOUT file. To work around
  this problem of WinEdit set the error file location in the default.env to an absolute file
  name, e.g. with 'ERRORFILE=c:\tmp\EDOUT' in the default.env and with
  'OUTPUT=c:\tmp\EDOUT' in the '[WinEdit]' section of the 'winedit.ini' file in the
  Windows directory.
- The pragma INTO_ROM is valid now only for the next definition of a variable or until a
  next segment pragma (CONST_SEG, CONST_SECTION, DATA_SEG,
  DATA_SECTION, CODE_SEG, CODE_SECTION).
- bug report cnibuffr.cpp (trane company)
- It was not possible to specify more than one of the -MsgSx options: fixed
- The standard predefined macro for C++ has changed from 'cplusplus__' to '__cplusplus'.
  It is not possible to specify zero bytes inside character strings, e.g. "a\0_abc".
  interrupt forward declaration
        Example:
     void interrupt 0 F1(void); /* 0xFFFE */
     void interrupt 0 F1(void) {} /* 0xFFFE */
  return type of function-pointer can be typedef
        Example:
     typedef enum {
       EN0 = 0,
       EN1
     } E;
     E h(void *pv) {
       E (*f) (int* pi);
     }

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object file
  format). The startup code do not support calling destructor functions.
     class A {
        int m;
        ~A();
     };
     A a;     // not calling destructor at end of program

- The ROM libraries are not initialized. This includes the zero out and copy down of global
  variables. C++ Constructor and Destructor calls are not done for ROM libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- C++ templates not fully working according ANSI standard.
- Declare Constant Byte with variables does not work, 2 bytes are allocated instead.
     Example:
        char a;
        DC.B a     ; allocates 2 bytes instead one
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
- Incorrect code is generated for following code:
        Example:
     char *p;
     *p++ |= 3;  /* set bit 1 && 3 */
     This bug occurs with all opassigns (*=, +=, ....) when the left side contains side effects.
  The side effect occurs twice instead of one time as defined by the ANSI standard.
        Workaround:
     char *p;
     *p |= 3;  /* set bit #1 && 3 */
     *p++;
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
      [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
- Be careful with -Oc and aliases:
  The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
  Register trace does not care about registers used in HLI blocks:
- Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the HLI
  assembly block.
        Workaround:
        Always save the register you are using at the beginning of an HLI assembly block and
  restore them at the end of the block.

Libraries
- setjmp/longjmp does not work in banked memory model


RELEASE NOTES CHC12 V5.0.05
  NOTE: Recompile all your sources

List of new Features
- C++ default arguments

List of fixed Bugs
- bug report cnibuffr.cpp (trane company)
- It was not possible to specify more than one of the -MsgSx options: fixed
- The standard predefined macro for C++ has changed from 'cplusplus__' to
  '__cplusplus'.
- It is not possible to specify zero bytes inside character strings, e.g. "a\0_abc".
  Instructions were moved across instructions with volatile memory accesses. This
  danger is removed now.
- Bug with accesses to elements of arrays with unknown size fixed.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object file
  format). The startup code do not support calling destructor functions.
     class A {
        int m;
        ~A();
     };
     A a;     // not calling destructor at end of program

- The ROM libraries are not initialized. This includes the zero out and copy down of global
  variables. C++ Constructor and Destructor calls are not done for ROM libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
- C++ templates not fully working according ANSI standard.
- Declare Constant Byte with variables does not work, 2 bytes are allocated instead.
        Example:
     char a;
     DC.B a     ; allocates 2 bytes instead one
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
- Incorrect code is generated for following code:
        Example:
     char *p;
     *p++ |= 3;  /* set bit 1 && 3 */
     This bug occurs with all opassigns (*=, +=, ....) when the left side contains side effects.
  The side effect occurs twice instead of one time as defined by the ANSI standard.
        Workaround:
     char *p;
     *p |= 3;  /* set bit #1 && 3 */
     *p++;
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
      [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
- Be careful with -Oc and aliases:
  The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
  Register trace does not care about registers used in HLI blocks:
- Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the HLI
  assembly block.
      Workaround:
      Always save the register you are using at the beginning of an HLI assembly block and
  restore them at the end of the block.

Libraries
- setjmp/longjmp does not work in banked memory model


RELEASE NOTES CHC12 V5.0.04
  NOTE: Recompile all your sources

List of new Features
- C++ default arguments

List of fixed Bugs
- bug report cnibuffr.cpp (trane company)
- It was not possible to specify more than one of the -MsgSx options: fixed
- The standard predefined macro for C++ has changed from 'cplusplus__' to
  '__cplusplus'.
- It is not possible to specify zero bytes inside character strings, e.g. "a\0_abc".

List of known Bugs
   Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object file
  format). The startup code do not support calling destructor functions.
     class A {
        int m;
        ~A();
     };
     A a;     // not calling destructor at end of program

- The ROM libraries are not initialized. This includes the zero out and copy down of global
  variables. C++ Constructor and Destructor calls are not done for ROM libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
  C++ templates not fully working according ANSI standard.
- Declare Constant Byte with variables does not work, 2 bytes are allocated instead.
   Example:
   char a;
   DC.B a     ; allocates 2 bytes instead one
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
- Incorrect code is generated for following code:
      Example:
   char *p;
   *p++ |= 3;  /* set bit 1 && 3 */
   This bug occurs with all opassigns (*=, +=, ....) when the left side contains side effects.
  The side effect occurs twice instead of one time as defined by the ANSI standard.
      Workaround:
   char *p;
   *p |= 3;  /* set bit #1 && 3 */
   *p++;
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
      [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
- Be careful with -Oc and aliases:
  The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
  Register trace does not care about registers used in HLI blocks:
- Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the HLI
  assembly block.
      Workaround:
      Always save the register you are using at the beginning of an HLI assembly block and
  restore them at the end of the block.

Libraries
- setjmp/longjmp does not work in banked memory model


RELEASE NOTES CHC12 V5.0.03

List of new Features
- BSR and JSR in HLI now possible to use a label or function with offset:
      Example:
   void foo(void);
   void main(void) {
     asm {
       BSR main
       BSR main:2
       Label:
       JSR main   ; optimized to BSR!
       JSR main:2 ; optimized to BSR!
       JSR Label  ; optimized to BSR!
       BSR ExitLabel
       ExitLabel:
     }
   }
- HLI Assembler does recognize now following instruction "MOVB  #12, 0, X".
- HLI Assembler now accepts variable names in IDX2 addressing mode:
      Example:
   char globalVar;

   void main(void) {
     asm {
       ldaa [globalVar,X]
     }
   }
- It is now possible to use the BSR/JSR optimization together with the -OdocF option.
      [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].

List of fixed Bugs
- Peephole optimizer was wrong for following case with register optimization (wrong
  BRA to RTS optimization), the code is now correct and optimal (even without -Or):
        Example:
     char flag;

     void main(char ch) {
       if ((flag & 10) == 10) {
         asm clra;
       }
     }

     00000000 1E00000A02   BRSET flag,#10,*+2   ;abs = 0007
     00000005 3D           RTS
     00000006 87           CLRA
     00000007 3D           RTS

  The offsets of symbolically accessed local variables in HLI assembler are updated.
  Local variables only accessed in inline assembler functions are allocated.

List of known Bugs
  Note: Some bugs do only concern the C++ version of the compiler.
- C++ Destructor call for global class objects (HI-CROSS and ELF/DWARF object file
  format). The startup code do not support calling destructor functions.
     class A {
        int m;
        ~A();
     };

     A a;     // not calling destructor at end of program
- The ROM libraries are not initialized. This includes the zero out and copy down of global
  variables. C++ Constructor and Destructor calls are not done for ROM libraries.
- The ELF/DWARF linker does not yet support debug info for ROM libraries.
  C++ templates not fully working according ANSI standard.
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
  Incorrect code is generated for following code:
      Example:
   char *p;
   *p++ |= 3;  /* set bit 1 && 3 */
   This bug occurs with all opassigns (*=, +=, ....) when the left side contains side
  effects. The side effect occurs twice instead of one time as defined by the ANSI
  standard.
      Workaround:
   char *p;
   *p |= 3;  /* set bit #1 && 3 */
   *p++;
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
      [Note: The -OdocF option (OptiHunter(tm)) is only available with a special
  license].
- Be careful with -Oc and aliases:
  The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
  Register trace does not care about registers used in HLI blocks:
- Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the HLI
  assembly block.
      Workaround:
      Always save the register you are using at the beginning of an HLI assembly block and
  restore them at the end of the block.

Libraries
- setjmp/longjmp does not work in banked memory model


RELEASE NOTES CHC12 V 5.0.02

List of new Features
- Additional tree optimization are now performed by the compiler.
   The tree optimizer handles now another topic :
   - optimization of only partially used values
  The tree optimization can be switched off using the compiler option -Ont.
- new peephole optimization which transforms JSR + RTS into JMP instructions. Use the
  option -OnP=h to switch it off.
- spills are now accessed directly from the stack. Prior compiler versions did always reload
  a value into a register before using them.
        Example:
     int f(void);
     int g(void);
     int main(void) {
        return f() | g();
      }
- division by zero raises an error
- local variable reordering the position of a local variable now depends on the number of
  the usage. Often used local variables are closer to the top of the stack, so that more
  often shorter accesses can be used. Not via the stack used local variables and register
  parameters are not allocated. Note that register variables (-or) were not allocated on
  the stack even in previous compiler versions. The last parameter, passed in a register
  parameters is not always pushed as first step in the entry code. it may now be stored
  anywhere between the local variables, if they it is used and allocated on the stack at
  all.

List of fixed Bugs
- The compiler generates now correct code for following portion of code. The previous
  compiler versions did not detect a possible change in the array content during "f(a)"
  and directly used the value 0 for a[0].
     Example:
     void f(long*);
     long main(void) {
       long a[1];
       a[0]=0;
       f(a);
       return a[0];
- The compiler did generate wrong code for the following portion of code
     void f(unsigned char* *);
     void main(void) {
       unsigned char* c;
       f(&c);
       *(c++)= 0;
       *c= 0;
     }
  The compiler assigns zero two times to the same location. This compiler problem only
  occur in the following case:
  The address of a local variable has been taken "f(&c)".
  A local variable is modified by a autoincrement / autodecrement
  The new value is used in linear code
- The compiler did generate incorrect code for following portion of code, when the
  option "-oc" was activated :
   long vl[20];
   void main(void) {
     long l1var= 4370;
     long * l1;
     void * v;
     l1var = vl[8] , l1 = &l1var , v = l1;
     if ((*(long *)v) != 4370) Error();
   }
- The previous compiler versions were not stable for the following code
   char a[1];  /* must be of size 1 or 2 */
   int i;
   void f(char*);
   main() {
     while (i < 60) {
       a[0] = 0;
     }
     f(a);
   }

List of known Bugs
- C++ Destructor call for global class objects (HI-CROSS object file format). The HI-
  CROSS linker and the startup code do not support calling destructor functions.
   class A {
      int m;
      ~A();
   };

   A a;     // not calling destructor at end of program
  The ELF/DWARF linker does not yet support global class objects.
  C++ templates not fully working according ANSI standard.
  HLI Assembler does not recognized following instruction "MOVB  #12, 0, X".
      Workaround:
      Split the expression into 2 statements.
   ...
   void main(void)
   {
     asm {
      LDD  #12
      STD  0. X
   ...
     };
     ...
   }
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
  Label addressing do not work with BSR/JSR instruction
   }
- Incorrect code is generated for following code:
      Example:
   char *p;
   *p++ |= 3;  /* set bit #1 && 3 */
   This bug occurs with all opassigns (*=, +=, ....) when the left side contains side
  effects. The side effect occurs twice instead of one time as defined by the ANSI
  standard.
     Workaround:
   char *p;
   *p |= 3;  /* set bit #1 && 3 */
   *p++;
- Function addressing mode in HLI for BSR not supported yet
   A function name is not accepted as target for a BSR instruction..
   Example:
   void func(void) {
     ...
   }
   ...
   void main(void)
   {
     asm {
       BSR func;
     ...
     };
     ...
   }
      Workaround:
      Use a JSR to jump to the external..
   void func(void) {
     ...
   }
   ...
   void main(void)
   {
     asm {
       JSR func;
     ...
     };
     ...
   }
- HLI Assembler does not handle IDX2 addressing mode properly, when the offset is
 specified trough an object name.
      Compiler does not generate correct code for following portion of code.
      Example:
   unsigned int var;
   ...
   void main(void)
   {
     asm {
       LDD [var, X];
     ...
     };
     ...
   }
      Workaround:
      Split the expression into 2 statements.
   unsigned int var;
   ...
   void main(void)
   {
     asm {
       LDD  #var
       LDD [D, X];
     ...
     };
     ...
   }
- Wrong code may be generated when the DOC feature is used while the JSR to BSR
  optimization is activated.
      [Note: The -OdocF option (OptiHunter(tm)) is only available with a special
  license].
      Workaround:
      To avoid this problem just disable the JSR to BSR optimization if the -OdocF option
  is used. The optimization can be disabled using the compiler option -OnB=b.
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
        [Note: The -OdocF option (OptiHunter(tm)) is only available with a special
  license].
- Some chips of the HC12 (M68HC8112A4) have incorrect behavior for Test/Inc/Dec
  and branch instructions (TBNE/TBEQ/IBNE/IBEQ/DBNE/DBEQ).
        To disable the generation of these instructions by the compiler use the -PX4 compiler
  option.
- Be careful with -Oc and aliases:
   The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
  Register trace does not care about registers used in HLI blocks:
     Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the HLI
  assembly block.
      Workaround:
      Always save the register you are using at the beginning of an HLI assembly block and
  restore them at the end of the block.
  The offsets of symbolically accessed local variables in HLI assembler are not correct.
  Actually the compiler ignores the access and uses the offset 0 in inline assembler
      Example:
   void main(void) {
     char i=4,j=5;
     asm {
       INC i
       INC j
     }
     if (i != 5 || j != 6) {
       Error();
     }
   }
      Note:
   The compiler sorts the variable locations and the last parameter of a function in any
  order. Not accessed variables (the compiler does not count accesses from HLI) are not
  even allocated.

Libraries
- setjmp/longjmp does not work in banked memory model


RELEASE NOTES CHC12 V 5.0.01

List of new Features
  HIWARE introduces a new generation of compilers (V5.0.x)
     The new generation of compilers includes the following features:

- The compiler is now a native 32 bit Win32 application. It is about two times
  faster than older 16 bit 2.7.x version on a Win32 system.
- The compiler runs with Windows 95, Windows NT 3.x, Windows NT 4.0 and Windows 3.11 with Win32s
  (Note that not all features are available under Win32s due restrictions of Microsoft)
- Fully windows oriented user interface (menus, tool bars, drag & drop)
- Online help
- Flexible Type Management
- Message Management
- Smart Sliders
- Rich set of compiler options both with graphical and command line setting
- Tip of the Day
- Direct link between compiler output and editor: simply double click on compiler
  message to open the source with the editor of your choice
- Editable command line with history
- Compiler option -Lc has been removed. The compiler always work in cooperative multitasking mode.

- Tree optimization are now performed by the compiler.
   This tree optimizer handles mainly
      - optimization of long compares
      - optimization of shift operations
      - using conversions and casts with character operations.
   The tree optimization can be switched off using the compiler option -Ont.
- New compiler option "-I" to specify additional include directories. E.g. "-Ic:\include"
   Remark that the primary source file (the one specified on the command line) is not
  searched in this list.

List of fixed Bugs
- Enumerated type constant can now be used in HLI assembler.
   Example:
   enum { Val0, Val1 };
   void main(void) {
     asm LDAA #Val1
   }
- Correct code is generated now for logical operation between elements from two distinct arrays.
- The compiler generates now correct code for following portion of code. In the previous
  version, the offset in the second register indirect access for arrays was wrong.
      Example:
   long a[10],b[10];
   long main4(void) {
     int i;
     return a[i]^b[i];
   }
  In the new compiler, elements in an array passed as parameter in a function call are not
  supposed to remain unchanged over function invocation.
     The compiler generates now correct code for following portion of code. The previous
  compiler versions did not detect a possible change in the array content during "f(a)"
  and directly used the value 0 for a[0].
      Example:
   void f(long*);
   long main(void) {
     long a[1];
     a[0]=0;
     f(a);
     return a[0];
   }

List of known Bugs
- HLI Assembler does not recognized following instruction "MOVB  #12, 0, X".
- The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
      Workaround:
      Split the expression into 2 statements.
   ...
   void main(void)
   {
     asm {
      LDD  #12
      STD  0. X
   ...
     };
     ...
   }
- Label addressing do not work with BSR/JSR instruction
- Function addressing mode in HLI for BSR not supported yet
   A function name is not accepted as target for a BSR instruction..
      Example:
   void func(void) {
     ...
   }
   ...
   void main(void)
   {
     asm {
       BSR func;
     ...
     };
     ...
   }
      Workaround:
      Use a JSR to jump to the external..
   void func(void) {
     ...
   }
   ...
   void main(void)
   {
     asm {
       JSR func;
     ...
     };
     ...
   }
- HLI Assembler does not handle IDX2 addressing mode properly, when the offset is
  specified trough an object name.
      Compiler does not generate correct code for following portion of code.
      Example:
   unsigned int var;
   ...
   void main(void)
   {
     asm {
       LDD [var, X];
     ...
     };
     ...
   }
      Workaround:
      Split the expression into 2 statements.
   unsigned int var;
   ...
   void main(void)
   {
     asm {
       LDD  #var
       LDD [D, X];
     ...
     };
     ...
   }
- Incorrect code is generated for following code:
   char *p;
   *p++ |= 1;  /* set bit #1 */
      Workaround:
      Split the expression into 2 statements.
   char *p;
   *p |= 1;
   p++;
- Wrong code may be generated when the DOC feature is used while the JSR to BSR
  optimization is activated.
      [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
      Workaround:
      To avoid this problem just disable the JSR to BSR optimization if the -OdocF option
  is used. The optimization can be disabled using the compiler option --OnB=b.
- The -OdocF option does not care about illegal option combinations (e.g. mixing
  memory models).
      [Note: The -OdocF option (OptiHunter(tm)) is only available with a special license].
  Some chips of the HC12 (M68HC8112A4) have incorrect behavior for Test/Inc/Dec
  and branch instructions (TBNE/TBEQ/IBNE/IBEQ/DBNE/DBEQ).
      To disable the generation of thus instructions by the compiler use the -PX4 compiler
  option.
- Be careful with -Oc and aliases:
   The common subexpression elimination (option -Oc) cannot check for all cases if a
  memory location is referenced with several pointers, e.g. a pointer pointing to itself.
- Register trace does not care about registers used in HLI blocks:
   Mixing HLI and HLL statements may be incorrect, because the compiler does not
  detect the registers destroyed in HLI assembler. The compiler may suppose that a
  register still keep a certain value, even when this register has been changed in the HLI
  assembly block.
      Workaround:
      Always save the register you are using at the beginning of an HLI assembly block and
  restore them at the end of the block.
- The compiler generates wrong code for the following portion of code
   void f(unsigned char* *);
   void main(void) {
     unsigned char* c;
     f(&c);
     *(c++)= 0;
     *c= 0;
   }
- The compiler assigns zero two times to the same location. This compiler problem only
  occur in the following case:
  The address of a local variable has been taken "f(&c)".
  A local variable is modified by a autoincrement / autodecrement
  The new value is used in linear code
  The compiler generated incorrect code for following portion of code, when the option
  "-oc" is activated :
     long vl[20];
     void main(void) {
       long l1var= 4370;
       long * l1;
       void * v;
       l1var = vl[8] , l1 = &l1var , v = l1;
       if ((*(long *)v) != 4370) Error();
     }
- The option -oc does not work correctly for the expanded long access to v. This
  compiler problem only occur in the following case:
  The option "-oc" is specified
  The option "-ont" is not specified
  A long compare with a variable with a casted type is used
        Workaround:
     Do not use "-oc" in this case:
     Note:
     The second common subexpression elimination "-one" does not have this problem

Libraries
- setjmp/longjmp does not work in banked memory model

