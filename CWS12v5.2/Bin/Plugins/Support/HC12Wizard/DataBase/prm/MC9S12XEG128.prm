/* This is a linker parameter file for the MC9S12XEG128 */

$$IF $$COND_XGATE$$ != 0 && $$COND_XGATE$$ != 1
$$ERROR $$COND_XGATE$$ must be a macro set with 0 or 1
$$ENDIF
$$IF $$XGATE_ASM_ONLY_RAM$$ != 0 && $$XGATE_ASM_ONLY_RAM$$ != 1
$$ERROR $$XGATE_ASM_ONLY_RAM$$ must be a macro set with 0 or 1
$$ENDIF
$$//  $$COND_XGATE$$: This macro defines if the XGATE should be supported
$$//  $$XGATE_ASM_ONLY_RAM$$: this macro defines if we only have assembly code and therefore no
$$//            C startup code which could copy the XGATE code from FLASH into RAM

$$IF $$COND_XGATE$$
/*
   This parameter file is setup in a generic way to allow exploring most common features of both cores:
   - S12X core
   - XGATE code and constants in FLASH and/or RAM
   - XGATE data and stack in RAM
   It might be required to adapt some of the definitions to best match your application.
*/
$$ELSE
/*
This file is setup to use the HCS12X core only.
If you plan to also use the XGATE in your project, best create a new project with the
'New Project Wizard' (File|New... menu in the CodeWarrior IDE) and choose the appropriate
project parameters.
*/
$$ENDIF

NAMES
    /* CodeWarrior will pass all the needed files to the linker by command line. But here you may add your additional files */
END

SEGMENTS /* here all RAM/ROM areas of the device are listed. Used in PLACEMENT below. All addresses are 'logical' */
/* Register space  */
/*    IO_SEG        = PAGED         0x0000 TO   0x07FF; intentionally not defined */

/* non-paged EEPROM */
      EEPROM        = READ_ONLY   DATA_NEAR IBCC_NEAR  0x0C00 TO   0x0FFF; 

/* non-paged RAM */
$$IF $$COND_XGATE$$
      RAM           = READ_WRITE  DATA_NEAR            0x2000 TO   0x3FFF ALIGN 2[1:1]; /* word align for XGATE accesses */
$$ELSE
      RAM           = READ_WRITE  DATA_NEAR            0x2000 TO   0x3FFF; 
$$ENDIF
$$IF $$COND_XGATE$$ && $$MAPPING_RAM$$
      RAM_4000      = READ_WRITE  DATA_NEAR          0x4000 TO 0x7FFF ALIGN 2[1:1]; /* word align for XGATE accesses */
$$ENDIF
$$IF ! $$COND_XGATE$$ && $$MAPPING_RAM$$
      RAM_4000      = READ_WRITE  DATA_NEAR          0x4000 TO 0x7FFF; 
$$ENDIF


/* non-banked FLASH */
$$IF $$MAPPING_FLASH$$
      ROM_4000      = READ_ONLY   DATA_NEAR IBCC_NEAR 0x4000 TO 0x7FFF; 
$$ENDIF
$$IF $$MAPPING_EXTERNAL$$
      /* Note: Change the access mode depending on your actual resources mapped to this area, default is ROM: */
      EXT_4000      = READ_ONLY   DATA_NEAR IBCC_NEAR 0x4000 TO 0x7FFF; 
$$ENDIF

      ROM_C000      = READ_ONLY   DATA_NEAR IBCC_NEAR  0xC000 TO   0xFEFF; 
/*    VECTORS       = READ_ONLY                        0xFF00 TO   0xFFFF; intentionally not defined: used for VECTOR commands below */
    //OSVECTORS     = READ_ONLY                        0xFF10 TO   0xFFFF;  /* OSEK interrupt vectors (use your vector.o) */

/* paged EEPROM                     0x0800 TO   0x0BFF; addressed through EPAGE */
      EEPROM_00     = READ_ONLY   DATA_FAR IBCC_FAR  0x000800 TO 0x000BFF; 
      EEPROM_01     = READ_ONLY   DATA_FAR IBCC_FAR  0x010800 TO 0x010BFF; 
      EEPROM_02     = READ_ONLY   DATA_FAR IBCC_FAR  0x020800 TO 0x020BFF; 
      EEPROM_03     = READ_ONLY   DATA_FAR IBCC_FAR  0x030800 TO 0x030BFF; 
      EEPROM_04     = READ_ONLY   DATA_FAR IBCC_FAR  0x040800 TO 0x040BFF; 
      EEPROM_05     = READ_ONLY   DATA_FAR IBCC_FAR  0x050800 TO 0x050BFF; 
      EEPROM_06     = READ_ONLY   DATA_FAR IBCC_FAR  0x060800 TO 0x060BFF; 
      EEPROM_07     = READ_ONLY   DATA_FAR IBCC_FAR  0x070800 TO 0x070BFF; 
      EEPROM_08     = READ_ONLY   DATA_FAR IBCC_FAR  0x080800 TO 0x080BFF; 
      EEPROM_09     = READ_ONLY   DATA_FAR IBCC_FAR  0x090800 TO 0x090BFF; 
      EEPROM_0A     = READ_ONLY   DATA_FAR IBCC_FAR  0x0A0800 TO 0x0A0BFF; 
      EEPROM_0B     = READ_ONLY   DATA_FAR IBCC_FAR  0x0B0800 TO 0x0B0BFF; 
      EEPROM_0C     = READ_ONLY   DATA_FAR IBCC_FAR  0x0C0800 TO 0x0C0BFF; 
      EEPROM_0D     = READ_ONLY   DATA_FAR IBCC_FAR  0x0D0800 TO 0x0D0BFF; 
      EEPROM_0E     = READ_ONLY   DATA_FAR IBCC_FAR  0x0E0800 TO 0x0E0BFF; 
      EEPROM_0F     = READ_ONLY   DATA_FAR IBCC_FAR  0x0F0800 TO 0x0F0BFF; 
      EEPROM_10     = READ_ONLY   DATA_FAR IBCC_FAR  0x100800 TO 0x100BFF; 
      EEPROM_11     = READ_ONLY   DATA_FAR IBCC_FAR  0x110800 TO 0x110BFF; 
      EEPROM_12     = READ_ONLY   DATA_FAR IBCC_FAR  0x120800 TO 0x120BFF; 
      EEPROM_13     = READ_ONLY   DATA_FAR IBCC_FAR  0x130800 TO 0x130BFF; 
      EEPROM_14     = READ_ONLY   DATA_FAR IBCC_FAR  0x140800 TO 0x140BFF; 
      EEPROM_15     = READ_ONLY   DATA_FAR IBCC_FAR  0x150800 TO 0x150BFF; 
      EEPROM_16     = READ_ONLY   DATA_FAR IBCC_FAR  0x160800 TO 0x160BFF; 
      EEPROM_17     = READ_ONLY   DATA_FAR IBCC_FAR  0x170800 TO 0x170BFF; 
      EEPROM_18     = READ_ONLY   DATA_FAR IBCC_FAR  0x180800 TO 0x180BFF; 
      EEPROM_19     = READ_ONLY   DATA_FAR IBCC_FAR  0x190800 TO 0x190BFF; 
      EEPROM_1A     = READ_ONLY   DATA_FAR IBCC_FAR  0x1A0800 TO 0x1A0BFF; 
      EEPROM_1B     = READ_ONLY   DATA_FAR IBCC_FAR  0x1B0800 TO 0x1B0BFF; 
      EEPROM_1C     = READ_ONLY   DATA_FAR IBCC_FAR  0x1C0800 TO 0x1C0BFF; 
      EEPROM_1D     = READ_ONLY   DATA_FAR IBCC_FAR  0x1D0800 TO 0x1D0BFF; 
      EEPROM_1E     = READ_ONLY   DATA_FAR IBCC_FAR  0x1E0800 TO 0x1E0BFF; 
      EEPROM_1F     = READ_ONLY   DATA_FAR IBCC_FAR  0x1F0800 TO 0x1F0BFF; 
      EEPROM_FE     = READ_ONLY   DATA_FAR IBCC_FAR  0xFE0800 TO 0xFE0BFF; 
/*    EEPROM_FF     = READ_ONLY                      0xFF0800 TO 0xFF0BFF; intentionally not defined: equivalent to EEPROM */

/* paged RAM:                       0x1000 TO   0x1FFF; addressed through RPAGE */
$$IF $$COND_XGATE$$
      RAM_XGATE_STK_L_ = NO_INIT  DATA_FAR           0xFD1000 TO 0xFD107D; 
      RAM_XGATE_STK_L = NO_INIT   DATA_FAR           0xFD107E TO 0xFD107F; 
      RAM_XGATE_STK_H_ = NO_INIT  DATA_FAR           0xFD1080 TO 0xFD10FD; 
      RAM_XGATE_STK_H = NO_INIT   DATA_FAR           0xFD10FE TO 0xFD10FF; 
$$IF $$XGATE_ASM_ONLY_RAM$$
      RAM_FD_L      = READ_WRITE  DATA_FAR           0xFD1100 TO 0xFD17FF ALIGN 2[1:1]; /* is also mapped to XGATE:  0xD100..0xD7FF */
      RAM_FD_H      = READ_WRITE  DATA_FAR           0xFD1800 TO 0xFD1FFF ALIGN 2[1:1]; /* is also mapped to XGATE:  0xD800..0xDFFF */
$$ELSE
      RAM_FD        = READ_WRITE  DATA_FAR           0xFD1100 TO 0xFD1FFF ALIGN 2[1:1]; /* is also mapped to XGATE:  0xD100..0xDFFF */
$$ENDIF
/*    RAM_FE        = READ_WRITE  0xFE1000 TO 0xFE1FFF; intentionally not defined: equivalent to RAM: 0x2000..0x2FFF */
/*    RAM_FF        = READ_WRITE  0xFF1000 TO 0xFF1FFF; intentionally not defined: equivalent to RAM: 0x3000..0x3FFF */
$$ELSE
      RAM_FD        = READ_WRITE  DATA_FAR           0xFD1000 TO 0xFD1FFF; 
/*    RAM_FE        = READ_WRITE                     0xFE1000 TO 0xFE1FFF; intentionally not defined: equivalent to RAM: 0x2000..0x2FFF */
/*    RAM_FF        = READ_WRITE                     0xFF1000 TO 0xFF1FFF; intentionally not defined: equivalent to RAM: 0x3000..0x3FFF */
$$ENDIF

/* paged FLASH:                     0x8000 TO   0xBFFF; addressed through PPAGE */
$$IF $$COND_XGATE$$
      PAGE_E0_0     = READ_ONLY   DATA_FAR IBCC_FAR  0xE08000 TO 0xE087FF; /* cannot be mapped to XGATE; XGATE sees registers here */
      PAGE_E0       = READ_ONLY   DATA_FAR IBCC_FAR  0xE08800 TO 0xE0BFFF ALIGN 2[1:1]; /* is also mapped to XGATE:  0x0800..0x3FFF        */
      PAGE_E1       = READ_ONLY   DATA_FAR IBCC_FAR  0xE18000 TO 0xE1BFFF ALIGN 2[1:1]; /* is also mapped to XGATE:  0x4000..0x7FFF        */
      // cannot be mapped to XGATE; this module should NOT be used for HC12 code when also used for XGATE code since
      //the HC12 will have priority over the XGATE accessing the FLASH modules resulting very poor performance of
      //the XGATE: Check allocation of this ranges in PLACEMENT below!
$$ELSE
      PAGE_E0       = READ_ONLY   DATA_FAR IBCC_FAR  0xE08000 TO 0xE0BFFF; 
      PAGE_E1       = READ_ONLY   DATA_FAR IBCC_FAR  0xE18000 TO 0xE1BFFF;
$$ENDIF 
      PAGE_E2       = READ_ONLY   DATA_FAR IBCC_FAR  0xE28000 TO 0xE2BFFF; 
      PAGE_E3       = READ_ONLY   DATA_FAR IBCC_FAR  0xE38000 TO 0xE3BFFF; 
      PAGE_FC       = READ_ONLY   DATA_FAR IBCC_FAR  0xFC8000 TO 0xFCBFFF; 
/*    PAGE_FD       = READ_ONLY                      0xFD8000 TO 0xFDBFFF; intentionally not defined: equivalent to ROM_4000 */
$$IF $$COND_XGATE$$ && $$XGATE_ASM_ONLY_RAM$$
      ROM_XGATE     = READ_ONLY   DATA_FAR IBCC_FAR  0xFE8000 TO 0xFE86FF RELOCATE_TO 0xFD1100 ALIGN 2; 
      PAGE_FE       = READ_ONLY   DATA_FAR IBCC_FAR  0xFE8700 TO 0xFEBFFF; 
$$ELSE
      PAGE_FE       = READ_ONLY   DATA_FAR IBCC_FAR  0xFE8000 TO 0xFEBFFF; 
$$ENDIF
/*    PAGE_FF       = READ_ONLY                      0xFF8000 TO 0xFFBFFF; intentionally not defined: equivalent to ROM_C000 */
END

PLACEMENT /* here all predefined and user segments are placed into the SEGMENTS defined above. */
      _PRESTART,              /* Used in HIWARE format: jump to _Startup at the code start */
      STARTUP,                /* startup data structures */
      ROM_VAR,                /* constant variables */
      STRINGS,                /* string literals */
      VIRTUAL_TABLE_SEGMENT,  /* C++ virtual table segment */
    //.ostext,                /* eventually OSEK code  */
      NON_BANKED,             /* runtime routines which must not be banked */
      COPY                    /* copy down information: how to initialize variables */
$$IF $$CODE_AT_4000$$
                        INTO  ROM_C000, ROM_4000;
$$ELSE
                              /* in case you want to use ROM_4000 here as well, make sure
                                 that all files (incl. library files) are compiled with the
                                 option: -OnB=b */
                        INTO  ROM_C000/*, ROM_4000*/;
$$ENDIF

      DEFAULT_ROM       INTO           PAGE_FE,          PAGE_FC, PAGE_E3, PAGE_E2, 
$$IF $$COND_XGATE$$
                              /* PAGE_E1 intentionally not listed: assigned to XGATE */
$$ELSE
                              PAGE_E1, 
$$ENDIF

$$IF $$COND_XGATE$$
                              /* PAGE_E0 intentionally not listed: assigned to XGATE */
                              PAGE_E0_0;
$$ELSE
                              PAGE_E0;
$$ENDIF

$$IF $$COND_XGATE$$
$$IF $$COND_XGATE_IN_FLASH$$
      XGATE_VECTORS,          /* XGATE vector table is allocated in FLASH */
      XGATE_STRING,           /* XGATE string literals */
      XGATE_CONST,            /* XGATE constants */
      XGATE_CODE,             /* XGATE functions */
$$ENDIF
      XGATE_STRING_FLASH,     /* XGATE strings that should always go into flash */
      XGATE_CONST_FLASH,      /* XGATE constants what should always go into flash */
      XGATE_CODE_FLASH        /* XGATE code that should always run out of flash */
                        INTO  PAGE_E0, PAGE_E1; /* FLASH accessible by XGATE */

    //.stackstart,            /* eventually used for OSEK kernel awareness: Main-Stack Start */
      SSTACK,                 /* allocate stack first to avoid overwriting variables on overflow */
    //.stackend,              /* eventually used for OSEK kernel awareness: Main-Stack End */
      PAGED_RAM,              /* there is no need for paged data accesses on this derivative */
      DEFAULT_RAM             /* all variables, the default RAM location */
                        INTO  RAM;
      SHARED_DATA            /* variables that are shared between CPU12 and XGATE */
$$IF $$MAPPING_RAM$$
                        INTO  RAM, RAM_4000;
$$ELSE
                        INTO  RAM;
$$ENDIF

$$IF $$XGATE_ASM_ONLY_RAM$$
$$IF $$COND_XGATE_IN_FLASH$$
$$ELSE
      XGATE_VECTORS,          /* XGATE vector table has to be copied into RAM by HCS12X */
      XGATE_STRING,           /* XGATE string literals have to be copied into RAM by HCS12X */
      XGATE_CONST,            /* XGATE constants have to be copied into RAM by HCS12X */
      XGATE_CODE,             /* XGATE functions have to be copied into RAM by HCS12X */
$$ENDIF
      XGATE_STRING_RAM,       /* XGATE strings that should always go into RAM */
      XGATE_CONST_RAM,        /* XGATE constants what should always go into RAM */
      XGATE_CODE_RAM          /* XGATE code that should always run out of RAM */
                        INTO  ROM_XGATE;/* will be copied into RAM_FD */
$$ENDIF
$$ELSE
    //.stackstart,            /* eventually used for OSEK kernel awareness: Main-Stack Start */
      SSTACK,                 /* allocate stack first to avoid overwriting variables on overflow */
    //.stackend,              /* eventually used for OSEK kernel awareness: Main-Stack End */
      DEFAULT_RAM             /* all variables, the default RAM location */
                        INTO  RAM;

      PAGED_RAM         INTO  /* when using banked addressing for variable data, make sure to specify
                                 the option -D__FAR_DATA on the compiler command line */
                              RAM_FD;
$$ENDIF

$$IF $$COND_XGATE$$
$$IF $$XGATE_ASM_ONLY_RAM$$
      XGATE_DATA              /* data that are accessed by XGATE only */
                        INTO  RAM_FD_H;
$$ELSE
$$IF $$COND_XGATE_IN_FLASH$$
$$ELSE
      XGATE_VECTORS,          /* XGATE vector table has to be copied into RAM by HCS12X */
      XGATE_STRING,           /* XGATE string literals have to be copied into RAM by HCS12X */
      XGATE_CONST,            /* XGATE constants have to be copied into RAM by HCS12X */
      XGATE_CODE,             /* XGATE functions have to be copied into RAM by HCS12X */
$$ENDIF
      XGATE_STRING_RAM,       /* XGATE strings that should always go into RAM */
      XGATE_CONST_RAM,        /* XGATE constants what should always go into RAM */
      XGATE_CODE_RAM,         /* XGATE code that should always run out of RAM */
      XGATE_DATA              /* data that are accessed by XGATE only */
                        INTO  RAM_FD;

$$ENDIF
$$ENDIF

$$IF $$COND_XGATE$$
      XGATE_STK_L       INTO  RAM_XGATE_STK_L;
      XGATE_STK_H       INTO  RAM_XGATE_STK_H;
$$ENDIF

$$IF  $$USE_MEM_BANKER$$
      DISTRIBUTE        DISTRIBUTE_INTO
$$IF $$MAPPING_FLASH$$
                              ROM_4000,
$$ENDIF
$$IF $$MAPPING_EXTERNAL$$
//                            EXT_4000, /* Note: Uncomment this line if your external area is read-only */
$$ENDIF
                                       PAGE_FE, PAGE_FC, PAGE_E3, PAGE_E2, PAGE_E1, PAGE_E0;
      CONST_DISTRIBUTE  DISTRIBUTE_INTO
$$IF $$MAPPING_FLASH$$
                              ROM_4000,
$$ENDIF
$$IF $$MAPPING_EXTERNAL$$
//                            EXT_4000, /* Note: Uncomment this line if your external area is read-only */
$$ENDIF
                                       PAGE_FE, PAGE_FC, PAGE_E3, PAGE_E2, PAGE_E1, PAGE_E0;
      DATA_DISTRIBUTE   DISTRIBUTE_INTO
$$IF $$MAPPING_RAM$$
                              RAM_4000,
$$ENDIF
$$IF $$MAPPING_EXTERNAL$$
//                            EXT_4000, /* Note: Uncomment this line if your external area is RAM */
$$ENDIF
                              RAM, RAM_FD;
$$ENDIF
    //.vectors          INTO  OSVECTORS; /* OSEK vector table */
END


ENTRIES /* keep the following unreferenced variables */
    /* OSEK: always allocate the vector table and all dependent objects */
  //_vectab OsBuildNumber _OsOrtiStackStart _OsOrtiStart
END

STACKSIZE 0x100   /* size of the stack (will be allocated in DEFAULT_RAM) */

/* use these definitions in plane of the vector table ('vectors') above */
VECTOR 0 _Startup /* reset vector: this is the default entry point for a C/C++ application. */
//VECTOR 0 Entry  /* reset vector: this is the default entry point for an Assembly application. */
//INIT Entry      /* for assembly applications: that this is as well the initialization entry point */
