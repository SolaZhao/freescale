<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component documentation - Typical Usage
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>Byteflight</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="Byteflight.html">General Info</a><br />
<a href="ByteflightProperties.html">Properties</a><br />
<a href="ByteflightMethods.html">Methods</a><br />
<a href="ByteflightEvents.html">Events</a><br />
<a href="ByteflightUser Types.html">Types and constants</a><br />
<i>Typical Usage</i><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="Byteflight_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%">

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              Byteflight
            </div>
            <div class="descrtext">Byteflight communication interface</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">CPU Internal Peripherals-Communication</a>
              
              </span>
            </div>
          </div>
          
          <div class="text_title">
              Typical Usage:
      		</div>		 
    		  <div class="descr_line">                  
              (Examples of a typical usage of the component in user code.
               For more information please 
               see the page <a href="..\..\DOCs\BeanCodeTypicalUsage.html">Component Code 
               Typical Usage</a>.)                   
          </div>          

<div class="user_text">   
<br/>       
<!---DESCBEG DON'T CHANGE THIS-->
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
 <hr size="1" color="#BOBOBO"/>
 <!-- MENU -->
 <br/><b>Typical settings and usage of Byteflight component</b>
 <p>
  <UL>
<LI><b><a href="#Send">(1) Sending data </a></b><br/>
</LI><LI><b><a href="#ReceiveFIFO">(2) Receiving data with FIFO </a></b><br/>
</LI><LI><b><a href="#Receive">(3)  Receiving data with dedicated buffers</a></b><br/>
</LI><LI><b><a href="#SendPolling">(4) Sending data without interrupts</a></b><br/>
</LI><LI><b><a href="#ReceiveFIFOpolling">(5) Receiving data with FIFO without interrupts</a></b><br/>
</LI><LI><b><a href="#ReceivePolling">(6) Receiving data with dedicated buffers without interrupts</a></b><br/>
  </LI></UL>
 </p>
 <hr size="1" color="#BOBOBO"/>


<p>
<b>(1) <a name="Send">Sending data </a></b><br/>
Assume the component name "BF1"
and following component settings: <a href="ByteflightProperties.html#IntService">Interrupt service/event</a> - enabled, <a href="ByteflightProperties.html#TxBuf">Transmit buffers</a> - enabled with <a href="ByteflightProperties.html#TxCount">Transmit buffers count</a> = 1.
Event <a href="ByteflightEvents.html#OnFreeTxBuf">OnFreeTxBuf</a> is called at the end of data transmission. Parameter BufferNum indicates the buffer that became empty. Method <a href="ByteflightMethods.html#SendFrame">SendFrame</a> is used for data sending.
Only one transmit buffer is enabled with number 15. This number will be passed as a parameter of <a href="ByteflightMethods.html#SendFrame">SendFrame</a> method.

</p><p>
The example demonstrates sending of 5-byte message with identifier 68.
</p>
</FONT>
<PRE>
<I><U>MAIN.C</U></I>

#define MY_TX_BUF  15
#define MY_MSG_ID  68

byte flags;
byte err;
byte Data[5] = {1,2,3,4,5};

void main(void)
{

    :
   
  /* Clear "Complete" flag */
  flags = 0;
  
  /* Send message through buffer 15, with identifier 68 */
  err=BF1_SendFrame(MY_TX_BUF,MY_MSG_ID,5,&Data);
  if(err!=ERR_OK) {
    /* Handle an error */
  }

  /* Wait for communication complete */
  while(!flags) ;
  

    :

}


<I><U>EVENTS.C</U></I>

extern byte flags;

void BF1_OnFreeTxBuf(byte BufferNum)
{
  flags = 1;	/* Set "Complete" flag */
}

</PRE>

<hr size="1"/>

<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<p>
<B><a name="ReceiveFIFO">(2) Receiving data with FIFO</a></B><br/>
Assume the component name "BF1"
and following component settings: <a href="ByteflightProperties.html#IntService">Interrupt service/event</a> - enabled, <a href="ByteflightProperties.html#FIFObuf">Receive FIFO</a> - enabled, <a href="ByteflightProperties.html#FIFOsize">Size of FIFO</a> = 5,
 <a href="ByteflightProperties.html#FIFOAccMask">FIFO identifier acceptance mask</a> = 0xFF (all ID will be accepted), <a href="ByteflightProperties.html#FIFOrejectMask">FIFO identifier rejection mask</a> = 0xFF (no ID will be rejected).
Event <a href="ByteflightEvents.html#OnNotEmptyRx">OnNotEmptyRx</a> is called always, when there are data received in FIFO. Method <a href="ByteflightMethods.html#ReadFrame">ReadFrame</a> is used for data reading from FIFO with parameter 'BufferNum' = 0. The method must be called in <a href="ByteflightEvents.html#OnNotEmptyRx">OnNotEmptyRx</a> event to empty FIFO, otherwise the interrupt will be pending permanently.


</p><p>
The example demonstrates receiving a message with FIFO.
</p>
</FONT>
<PRE>
<I><U>MAIN.C</U></I>

byte flags;
byte Data[12];
byte id;
byte length;

void main(void)
{

    :
   
  /* Clear "Complete" flag */
  flags = 0;

  /* Wait for communication complete */
  while(!flags) ;

  /* Now Data field contains received message */
  

    :

}


<I><U>EVENTS.C</U></I>

#define FIFO_BUF 0

extern byte flags;
extern byte Data[12];
extern byte id;
extern byte length;
byte err;

void BF1_OnNotEmptyRx(void)
{
  /* Read message from FIFO */
  err=BF1_ReadFrame(FIFO_BUF,&id,&length,&Data);
  if(err!=ERR_OK) {
    /* Handle an error */
  }
  flags = 1;	/* Set "Complete" flag */

  /* Process received message */

}

</PRE>

<hr size="1"/>

<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<p>
<B><a name="Receive">(3) Receiving data with dedicated receive buffers</a></B><br/>
Assume the component name "BF1"
and following component settings: <a href="ByteflightProperties.html#IntService">Interrupt service/event</a> - enabled, <a href="ByteflightProperties.html#FIFObuf">Receive FIFO</a> - disabled, <a href="ByteflightProperties.html#RxBuf">Dedicated receive buffers</a> - enabled,  
<a href="ByteflightProperties.html#RxIDinit">Receive identifier init</a> may specify the ID of the message, that will be captured in this buffer.
Event <a href="ByteflightEvents.html#OnFullRxBuf">OnFullRxBuf</a> is called always, when there is message received in dedicated receive buffer. Parameter 'BufferNum' of the event contains a number of the buffer, which caused coming of the event. 
Method <a href="ByteflightMethods.html#ReadFrame">ReadFrame</a> is used for data reading from dedicated receive buffer determined by the parameter 'BufferNum'.
Identifier of the message that is captured by certain dedicated receive buffer may by changed with <a href="ByteflightMethods.html#SetAcceptanceCode">SetAcceptanceCode</a> method. This method may be called only in disabled state.

</p><p>
The example demonstrates receiving a message with dedicated receive buffer. The identifier of the message is 68.
</p>
</FONT>
<PRE>
<I><U>MAIN.C</U></I>

#define MY_RECV_BUF  0
#define MY_MSG_ID    68

byte flags;
byte Data[12];
byte id;
byte length;
byte RxBufNum;
byte err;

void main(void)
{

    :
  /* Disable the component */
  (void)BF1_Disable();

  /* Set acceptance ID of the buffer 0 to 68 */
  /* If the value is specified in property 'Receive identifier init', */
  /* the method need not to be called */
  err = BF1_SetAcceptanceCode(MY_RECV_BUF,MY_MSG_ID)
  if(err!=ERR_OK) {
    /* Handle possible error */
  }

  /* Clear "Complete" flag */
  flags = 0;

  /* Enable the component */
  (void)BF1_Enable();
   
  /* Wait for communication complete */
  while(!flags) ;

  /* Read message from the buffer */
  err=BF1_ReadFrame(RxBufNum,&id,&length,&Data);
  if(err!=ERR_OK) {
    /* Handle an error */
  }

  /* Now Data field contains received message */
  

    :

}


<I><U>EVENTS.C</U></I>

extern byte flags;
extern byte RxBufNum;

void BF1_OnFullRxBuf(byte BufferNum)
{
  /* Store the number of buffer with new message*/
  RxBufNum = BufferNum;    
  flags = 1;	/* Set "Complete" flag */
}

</PRE>
 <hr size="1" color="#BOBOBO"/>

<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<p>
<B>(4) <a name="SendPolling">Sending data without interrupts</a></B><br/>
Assume the component name "BF1"
and following component settings: <a href="ByteflightProperties.html#IntService">Interrupt service/event</a> - Disabled, <a href="ByteflightProperties.html#TxBuf">Transmit buffers</a> - enabled with <a href="ByteflightProperties.html#TxCount">Transmit buffers count</a> = 1.
Method <a href="ByteflightMethods.html#SendFrame">SendFrame</a> is used for data sending.
Only one transmit buffer is enabled with number 15. This number will be passed as a parameter of <a href="ByteflightMethods.html#SendFrame">SendFrame</a> method.
Finish of transmission can be determined by polling of <a href="ByteflightMethods.html#GetBufState">GetBufState</a> method, which returns the state of buffer full/free flag.

</p><p>
The example demonstrates sending of 5-byte message with identifier 68.
</p>
</FONT>
<PRE>
<I><U>MAIN.C</U></I>

#define MY_TX_BUF  15
#define MY_MSG_ID  68

byte err;
byte Data[5] = {1,2,3,4,5};

void main(void)
{

    :
   
  /* Send message through buffer 15, with identifier 68 */
  err=BF1_SendFrame(MY_TX_BUF,MY_MSG_ID,5,&Data);
  if(err!=ERR_OK) {
    /* Handle an error */
  }

  /* Wait for communication complete */
  while(!(BF1_GetBufState(MY_TX_BUF))) ;
  

    :

}

</PRE>

<hr size="1"/>

<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<p>
<B><a name="ReceiveFIFOpolling">(5) Receiving data with FIFO without interrupts</a></B><br/>
Assume the component name "BF1"
and following component settings: <a href="ByteflightProperties.html#IntService">Interrupt service/event</a> - disabled, <a href="ByteflightProperties.html#FIFObuf">Receive FIFO</a> - enabled, <a href="ByteflightProperties.html#FIFOsize">Size of FIFO</a> = 5,
 <a href="ByteflightProperties.html#FIFOAccMask">FIFO identifier acceptance mask</a> = 0xFF (all ID will be accepted), <a href="ByteflightProperties.html#FIFOrejectMask">FIFO identifier rejection mask</a> = 0xFF (no ID will be rejected).
A new message stored in FIFO can be determined by polling <a href="ByteflightMethods.html#GetStatus">GetStatus</a> method, which returns various status flags (see <a href="ByteflightUser Types.html">User Types</a>).
Method <a href="ByteflightMethods.html#ReadFrame">ReadFrame</a> is used for data reading from FIFO with parameter 'BufferNum' = 0. 


</p><p>
The example demonstrates receiving a message with FIFO in polling mode.
</p>
</FONT>
<PRE>
<I><U>MAIN.C</U></I>

#define FIFO_BUF 0

byte Data[12];
byte id;
byte length;
byte err;
BF1_TStatus statFlg;

void main(void)
{

    :
   
  do {
    /* Test the status flags */
    (void)GetStatus(&statFlg);
    /* Wait for reception of the message */
  }while(!statFlg.statusName.RcvFIFO);

  /* Read message from FIFO */
  err=BF1_ReadFrame(FIFO_BUF,&id,&length,&Data);
  if(err!=ERR_OK) {
    /* Handle an error */
  }

  /* Now Data field contains received message */
  
    :

}

</PRE>

<hr size="1"/>

<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<p>
<B><a name="ReceivePolling">(6) Receiving data with dedicated receive buffers without interrupts</a></B><br/>
Assume the component name "BF1"
and following component settings: <a href="ByteflightProperties.html#IntService">Interrupt service/event</a> - disabled, <a href="ByteflightProperties.html#FIFObuf">Receive FIFO</a> - disabled, <a href="ByteflightProperties.html#RxBuf">Dedicated receive buffers</a> - enabled,  
<a href="ByteflightProperties.html#RxIDinit">Receive identifier init</a> may specify the ID of the message, that will be captured in this buffer.
Receiving of a new message can be determined by polling of <a href="ByteflightMethods.html#GetBufState">GetBufState</a> method, which returns the state of buffer full/free flag.
Method <a href="ByteflightMethods.html#ReadFrame">ReadFrame</a> is used for data reading from dedicated receive buffer determined by the parameter 'BufferNum'.
Identifier of the message that is captured by certain dedicated receive buffer may by changed with <a href="ByteflightMethods.html#SetAcceptanceCode">SetAcceptanceCode</a> method. This method may be called only in disabled state.

</p><p>
The example demonstrates receiving a message with dedicated receive buffer. The identifier of the message is 68.
</p>
</FONT>
<PRE>
<I><U>MAIN.C</U></I>

#define MY_RECV_BUF  0
#define MY_MSG_ID    68

byte Data[12];
byte id;
byte length;
byte err;

void main(void)
{

    :
  /* Disable the component */
  (void)BF1_Disable();

  /* Set acceptance ID of the buffer 0 to 68 */
  /* If the value is specified in property 'Receive identifier init', */
  /* the method need not to be called */
  err = BF1_SetAcceptanceCode(MY_RECV_BUF,MY_MSG_ID)
  if(err!=ERR_OK) {
    /* Handle possible error */
  }

  /* Enable the component */
  (void)BF1_Enable();
   
  /* Wait for message reception */
  while(!(BF1_GetBufState(MY_RECV_BUF))) ;

  /* Read message from the buffer */
  err=BF1_ReadFrame(MY_RECV_BUF,&id,&length,&Data);
  if(err!=ERR_OK) {
    /* Handle an error */
  }

  /* Now Data field contains received message */
  

    :

}

</PRE>
<!---DESCEND DON'T CHANGE THIS-->
</div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            Copyright 1997 - 2010 Freescale Semiconductor, Inc.
          </p>
    </td>
  </tr>

</table>

</body>
</html>
