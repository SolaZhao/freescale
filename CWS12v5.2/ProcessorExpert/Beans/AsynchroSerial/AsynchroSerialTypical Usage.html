<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component documentation - Typical Usage
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>AsynchroSerial</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="AsynchroSerial.html">General Info</a><br />
<a href="AsynchroSerialProperties.html">Properties</a><br />
<a href="AsynchroSerialMethods.html">Methods</a><br />
<a href="AsynchroSerialEvents.html">Events</a><br />
<a href="AsynchroSerialUser Types.html">Types and constants</a><br />
<i>Typical Usage</i><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="AsynchroSerial_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%">

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              AsynchroSerial
            </div>
            <div class="descrtext">Asynchronous serial communication</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">CPU Internal Peripherals-Communication</a>
              
              </span>
            </div>
          </div>
          
          <div class="text_title">
              Typical Usage:
      		</div>		 
    		  <div class="descr_line">                  
              (Examples of a typical usage of the component in user code.
               For more information please 
               see the page <a href="..\..\DOCs\BeanCodeTypicalUsage.html">Component Code 
               Typical Usage</a>.)                   
          </div>          

<div class="user_text">   
<br/>       
<!---DESCBEG DON'T CHANGE THIS-->
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">All the following examples suppose the component name is "AS1".
<BR/>There are several typical usage modes:</FONT>
<UL>
<LI><A href="#Polling"><B>Without interrupts</B></A></LI>
<LI><A href="#InterruptWithEvent"><B>Using interrupts with events</B></A></LI>
<LI><A href="#BlockTransfer"><B>Usage of block transfer</B></A></LI>
<LI><A href="#RecvErrDetect"><B>Receive error detection</B></A></LI>
<LI><A href="#BreakDetect"><B>Break character detection</B></A></LI>
<LI><A href="#DMA"><B>Transfer using DMA</B></A></LI>
<LI><A href="#BaudrateMode"><B>Changing baud rate during run-time</B></A></LI>
</UL>

<HR />
<UL>
<LI>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<a name="Polling"><B>Without interrupts</B></a>
<P>The simplest mode of the AsynchroSerial component is setting with <a href="AsynchroSerialProperties.html#IntService">Interrupt service/event</a> 
disabled (so called polling mode). The code in this mode is very small and simple. However it is outweighed by the necessity to regularly check 
for incoming data and wait for transmitted data to complete.</P>
<P>The following example demonstrates a simple "Hello world" program. The program sends text "Hello world" and then waits until a character 'e' is received 
to send some other data.</P>
</FONT>
<PRE>
 <I><U>MAIN.C</U></I>

char message[] = "Hello world";
AS1_TComData ch;                                         // <a href="AsynchroSerialUser Types.html#TError">TComData</a> type is defined in the AS1.h header file
byte i, err;
void main(void)
{
  .
  .
  .
  for(i = 0; i &lt; sizeof(message); i++) {
    while(AS1_SendChar((byte)message[i]) != ERR_OK) {}   // trying to send a character until the SendChar method returns ERR_OK
  }

  ch = 0;
  do {                                                   // execute the loop until the character 'e' is received
    err = AS1_RecvChar(&ch);                             // check if a character is received
  } while((err != ERR_OK) && (ch != 'e'));               // test if the 'e' character was received

  while(AS1_SendChar((byte)'B') != ERR_OK) {}            // trying to send 'B' until success
  while(AS1_SendChar((byte)'Y') != ERR_OK) {}            // trying to send 'Y' until success
  .
  .
  .
  for(;;) {} 
}<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
</FONT>
</PRE>
<HR />
</LI>
<!--- 2 -->


<LI>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<a name="InterruptWithEvent"><B>Using interrupts with events</B></a>
<P>To avoid the necessity to continually check for incoming data the <a href="AsynchroSerialProperties.html#IntService">Interrupt service/event</a> 
property can be enabled (so called interrupt mode). In this mode the AsynchroSerial component uses the capability of the cpu to interrupt the flow of the
program to execute a different part of code. The hardware of the asynchroserial module may generate the interrupt upon various occasions - when a new 
character is received, when sending of a character is completed, when a receive error is detected, etc.
</P>
<P>The <A href="AsynchroSerialEvents.html">events</A> of the AsynchroSerial component are set of call-back functions, which are automatically invoked from 
the interrupt service routine. Because the body of the event function is defined by user it is possible to react immediately without wasting time in
waiting loops.
</P>
<P>The following example demonstrates usage of the <a href="AsynchroSerialEvents.html#OnRxChar">OnRxChar</a> event. The event is invoked when a character
is received. The example implements simple repeater - when OnRxChar event is invoked the received character is read and sent back.
</P>
</FONT>
<PRE>
 <I><U>EVENTS.C</U></I>

void AS1_OnRxChar(void)
{
  AS1_TComData ch;                         // <a href="AsynchroSerialUser Types.html#TError">TComData</a> type is defined in the AS1.h header file

  //Read received character and send it if no error is detected
  if(AS1_RecvChar(&ch) == ERR_OK)
    AS1_SendChar(ch);

}<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
</FONT>
</PRE>
<HR />
</LI>

<LI>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<A name="BlockTransfer"><B>Usage of block transfer</B></A>
<P>When in the interrupt mode (<a href="AsynchroSerialProperties.html#IntService">Interrupt service/event</a> property is enabled) the AsynchroSerial component can be configured
to define and use internal circular buffers to store received data or data for transmit. Instead of sending/receiving individual bytes user can work with
blocks of data.
</P>
<P>Send methods (<a href="AsynchroSerialMethods.html#SendChar">SendChar</a> and <a href="AsynchroSerialMethods.html#SendBlock">SendBlock</a>) store
data into the internal buffer. When the transmitter becomes empty one character from the internal buffer is sent, until the internal buffer is empty.</P>
<P>All received characters are placed into the internal buffer. Methods <a href="AsynchroSerialMethods.html#RecvChar">RecvChar</a> or <a href="AsynchroSerialMethods.html#RecvBlock">RecvBlock</a>
can be used to read later the data from the internal buffer.</P>

<P>The following program demonstrates a typical usage of block transfer functions. In this example the component will be used to receive and send fixed size packets of data.
The structure of the packet is - 1B header, 1B command, 2B data, 1B checksum</P>
<P>Suppose the following component settings:</P>
<UL>
<LI><a href="AsynchroSerialProperties.html#IntService">Interrupt service/event</a>: Enabled</LI>
<LI><a href="AsynchroSerialProperties.html#InpBufferSize">Input buffer size</a>:  5</LI>
<LI><a href="AsynchroSerialProperties.html#OutBufferSize">Output buffer size</a>: 5</LI>
<LI>Methods enabled: <a href="AsynchroSerialMethods.html#SendBlock">SendBlock</a>, <a href="AsynchroSerialMethods.html#RecvBlock">RecvBlock</a></LI>
<LI>Events enabled: <a href="AsynchroSerialEvents.html#OnFullRxBuf">OnFullRxBuf</a></LI>
</UL>
<P>Definition of the packet structure:</P>
</FONT>
<PRE>
struct {
  byte Header;
  byte Command;
  word Data;
  byte Checksum;
} message;
</PRE>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<P>A data packet fills the receive buffer, so the <a href="AsynchroSerialEvents.html#OnFullRxBuf">OnFullRxBuf</a> event is invoked when a data packet is received.
The received packet may be read using the <a href="AsynchroSerialMethods.html#RecvBlock">RecvBlock</a> method.</P>
<P>Example of the OnFullRxBuf event code:</P>
</FONT>
<PRE>
  void AS1_OnFullRxBuf(void)
  {
    word Received;
    byte err;
    err = AS1_RecvBlock((byte*)&message, sizeof(message), &Received);
    ....
  }
</PRE>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
To send a data packet the <a href="AsynchroSerialMethods.html#SendBlock">SendBlock</a> method may be used:
</FONT>
<PRE>
byte err;
word Sent;
void main(void)
{
  ...
  message.Header = 0x55;
  message.Command = 0x01;
  message.Data = 0x0A0B;
  message.Checksum = message.Header + message.Command + (message.Data & 0x00ff) + (message.Data >> 8);
  err = AS1_SendBlock((byte*)&message, sizeof(message), &Sent);
  ....
}
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
</FONT>
</PRE>
<HR />
</LI>
<LI>
<!--- 3 -->
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<A name="RecvErrDetect"><B>Receive error detection</B></A>
<P>The hardware of an asynchroserial module usually supports several methods of error detection - parity error, overrun error, etc.
The AsynchroSerial component contains basically two ways how to obtain information that an error has been detected:
<UL><LI> Return value of a receive method (<a href="AsynchroSerialMethods.html#RecvChar">RecvChar</a> or 
<a href="AsynchroSerialMethods.html#RecvBlock">RecvBlock</a>) - the method returns an error value ERR_COMMON in case 
that an receive error has been detected since the last successful call or during execution of the method</LI>
<LI><a href="AsynchroSerialEvents.html#OnError">OnError</a> event - this event is invoked immediately after a receive error has been detected</LI></UL>
</P>
<P>Both methods inform that an error has been detected, but no information about specific error type (if it is parity error, framing error, etc.).
This information is provided by the <a href="AsynchroSerialMethods.html#GetError">GetError</a> method.</P> 
<P>
In the polling mode (the <a href="AsynchroSerialProperties.html#IntService">Interrupt service/event</a> property is disabled) the only way to detect 
a receive error is the return value of the <a href="AsynchroSerialMethods.html#RecvChar">RecvChar</a> method. The following example demonstrates 
typical error detection scheme in this mode.
</P>
</FONT>
<PRE>
 <I><U>MAIN.C</U></I>

AS1_TComData ch;                         // <a href="AsynchroSerialUser Types.html#TError">TComData</a> type is defined in the AS1.h header file
byte err;
AS1_TError error;                       // <a href="AsynchroSerialUser Types.html#TError">TError</a> type is defined in the AS1.h header file
void main(void)
{
  .
  .
  .
  do {
    err = AS1_RecvChar(&ch);            // test if a character is received
  } while (err != ERR_EMPTY);           // execute the loop until a character is received
  
  if (err = ERR_COMMON) {               // if an error was detected
    AS1_GetError(&error);               // determine the type of error
    if (error.ErrName.Parity) {
      //Parity error
    } else if (error.errName.Framing) {
      //Framing error
    } else if ...
  }
}
</PRE>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<P>When in the interrupt mode <a href="AsynchroSerialProperties.html#IntService">Interrupt service/event</a> property is enabled) the preferred method 
to detect a receive error is to use the <a href="AsynchroSerialEvents.html#OnError">OnError</a> event. The 
<a href="AsynchroSerialMethods.html#RecvChar">RecvChar</a>/<a href="AsynchroSerialMethods.html#RecvBlock">RecvBlock</a> methods also return information
about the receive error, but this information is redundant and should not be used when <a href="AsynchroSerialEvents.html#OnError">OnError</a> method is enabled.
Please note that the <a href="AsynchroSerialMethods.html#GetError">GetError</a> method returns information which communication errors happened since the
last call of this method. As a result when <a href="AsynchroSerialMethods.html#GetError">GetError</a> method is already called in the <a href="AsynchroSerialEvents.html#OnError">OnError</a> event
then call after e.g. <a href="AsynchroSerialMethods.html#RecvChar">RecvChar</a> method will not return which error has occurred.
</P>
<P>The following example demonstrates typical error detection scheme in the interrupt mode.</P>
</FONT>
<PRE>
 <I><U>EVENTS.C</U></I>

void AS1_OnError(void)
{
  AS1_TError error;        // <a href="AsynchroSerialUser Types.html#TError">TError</a> type is defined in the AS1.h header file
  
  AS1_GetError(&error);    // determine the type of error
  if(error.errName.Parity) {
    //Parity error
  } else if(error.errName.Framing){
    //Framing error
  } else if ... 
}<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
</FONT>
</PRE>

<HR />
</LI>
<LI>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<A name="BreakDetect"><B>Break character detection</B></A>
<P>Break character consists of several zeros and has no start bit nor stop bit. Depending on configuration of the asynchroserial module the break character 
may consist of 10 or more consecutive zeros. To enable handling of the break character the <a href="AsynchroSerialProperties.html#SerBreak">Break signal</a> 
property must be enabled.</P>
<P>The behaviour of AsynchroSerial component depends on the setting of the <a href="AsynchroSerialProperties.html#IntService">Interrupt service/event</a> property.
In the <U>polling mode</U> the <a href="AsynchroSerialMethods.html#RecvChar">RecvChar</a> method returns error code ERR_BREAK when break character is detected.
In the <U>interrupt mode</U>, when a break character is detected the <a href="AsynchroSerialEvents.html#OnBreak">OnBreak</a> event is invoked (if enabled) and the receive methods 
(<a href="AsynchroSerialMethods.html#RecvChar">RecvChar</a>/<a href="AsynchroSerialMethods.html#RecvBlock">RecvBlock</a>) return error code ERR_COMMON.
</P>
<P>In the interrupt mode when <a href="AsynchroSerialEvents.html#OnBreak">OnBreak</a> event is not enabled either 
<a href="AsynchroSerialMethods.html#GetError">GetError</a> or <a href="AsynchroSerialMethods.html#GetBreak">GetBreak</a> method can
be used to get information if break character has been detected.
</P>
<P> Example of using <a href="AsynchroSerialMethods.html#GetError">GetError</a> method to test break character reception (event <a href="AsynchroSerialEvents.html#OnBreak">OnBreak</a> disabled):</P>

</FONT>
<PRE>
 <I><U>EVENTS.C</U></I>

AS1_TComData ch;                        // <a href="AsynchroSerialUser Types.html#TError">TComData</a> type is defined in the AS1.h header file

void AS1_OnRxChar(void)
{
  byte err;
  AS1_TError error;                     // <a href="AsynchroSerialUser Types.html#TError">TError</a> type is defined in the AS1.h header file

  err = AS1_RecvChar(&ch);              // receive a character
  
  if (err = ERR_COMMON) {               // if an error was detected
    AS1_GetError(&error);               // determine the type of error
    if (error.Break) {
                // break character has been received
    } else {
                // a receive error detected
    }
  }
}
</PRE>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<P>Example of using <a href="AsynchroSerialMethods.html#GetBreak">GetBreak</a> method to test break character reception (event <a href="AsynchroSerialEvents.html#OnBreak">OnBreak</a> disabled):</P>
</FONT>
<PRE>
 <I><U>EVENTS.C</U></I>

AS1_TComData ch;                        // <a href="AsynchroSerialUser Types.html#TError">TComData</a> type is defined in the AS1.h header file

void AS1_OnRxChar(void)
{
  boll break;
  AS1_TError error;                     // <a href="AsynchroSerialUser Types.html#TError">TError</a> type is defined in the AS1.h header file

  err = AS1_RecvChar(&ch);              // receive a character
  
  if (err = ERR_COMMON) {               // if an error was detected
    AS1_GetBreak(&break);
    if (break)) {
                // break character has been received
    } else {
                // a receive error detected
    }
  }
}
</PRE>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<P><b>Note:</b> When both the <a href="AsynchroSerialMethods.html#GetBreak">GetBreak</a> and <a href="AsynchroSerialMethods.html#GetError">GetError</a> methods
are enabled, the <a href="AsynchroSerialMethods.html#GetBreak">GetBreak</a> method has to be called before the <a href="AsynchroSerialMethods.html#GetError">GetError</a> method,
because both methods use the same internal flags. Calling <a href="AsynchroSerialMethods.html#GetError">GetError</a> clears this flag so the 
<a href="AsynchroSerialMethods.html#GetBreak">GetBreak</a> method will not return correct information.</P>
</FONT>
<HR />
</LI>
<!--- 4 -->
<LI>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<A name="DMA"><B>Transfer using DMA</B></A>
<BR/>The next typical usage of this component is a communication using DMA transfer. Interrupts can be enabled or disabled.
    This typical usage can be used by the derivatives with a DMA controller.

</FONT>
<PRE>
 <I><U>MAIN.C</U></I>
AS1_TComData ch;                        // <a href="AsynchroSerialUser Types.html#TError">TComData</a> type is defined in the AS1.h header file
AS1_TError error;                       // <a href="AsynchroSerialUser Types.html#TError">TError</a> type is defined in the AS1.h header file
void main(void)
{

  //Start DMA request (DMA request have to be specified first!)
  AS1_RecvChar(&ch);

  //Wait for any character
  while(AS1_GetCharsInRxBuf() == 0);

  //Read the last communication errors
  AS1_GetError(&error)
  if(error.err == 0)
    //Send the last received character if no error is detected
    AS1_SendChar(ch);
  else
    if(error.errName.Parity)
      //Parity error
    else if(error.errName.Framing)
      //Framing error
    .
    .
    .
}

 <I><U>EVENTS.C</U></I>

void AS1_OnFullRxBuf(void)
{
  //Requested data have been received. DMA transfer is finished.
}

void AS1_OnFreeTxBuf(void)
{
  //Requested data have been sent. DMA transfer is finished.
}<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
</FONT>
</PRE>
<HR />
</LI>


<!--- 6 -->
<LI>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<A name="BaudrateMode"><B>Changing baud rate during run-time</B></A>
<P>The AsynchroSerial component allows user to change baud rate value at runtime.</P>
<P>In the timing dialog of the <a href="AsynchroSerialProperties.html#_BdRate">Baud rate</a> property set runtime setting type to "from list of values". Then it is possible
to enter up to 16 different values. The <a href="AsynchroSerialMethods.html#SetBaudRateMode">SetBaudRateMode</a> method is used to select the actual baud rate.
The component generates a special symbolic constant for each baud rate value defined (see <a href="AsynchroSerialMethods.html#SetBaudRateMode">SetBaudRateMode</a>),
e.g. AS1_BM_2400BAUD, AS1_BM_4800BAUD, etc. The constant is used as a parameter of the SetBaudRateMode method.</P>
</FONT>
<PRE>

void main(void) {
  ...
  AS1_SetBaudRateMode(AS1_BM_2400BAUD)
  ...
  ...
  AS1_SetBaudRateMode(AS1_BM_4800BAUD)
  ..
}
</PRE>
<HR />
</LI>
</UL>
<!---DESCEND DON'T CHANGE THIS-->
</div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            Copyright 1997 - 2011 Freescale Semiconductor, Inc.
          </p>
    </td>
  </tr>

</table>

</body>
</html>
