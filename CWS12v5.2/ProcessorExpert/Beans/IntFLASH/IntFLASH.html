<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component documentation - General info
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>IntFLASH</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<i>General Info</i><br />
<a href="IntFLASHProperties.html">Properties</a><br />
<a href="IntFLASHMethods.html">Methods</a><br />
<a href="IntFLASHEvents.html">Events</a><br />
<a href="IntFLASHUser Types.html">Types and constants</a><br />
<a href="IntFLASHTypical Usage.html">Typical Usage</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="IntFLASH_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%">

           <div class="titlebox">
              <div class="beanname">
                Component
                
                
                IntFLASH
              </div>              
              <div class="descrtext">Internal FLASH</div>
              <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
              <div class="info_name">Category: 
                <span class="info_text">
                <a href="../../DOCs/BeanCategoriesInfo.html">CPU Internal Peripherals-Memory</a>
                
                </span>
              </div>
            </div>
            <div class="user_text">
<!---DESCBEG DON'T CHANGE THIS-->
<p> This component provides access to the CPU internal FLASH memory.
The entire FLASH memory must be mapped into the address space of the CPU.
The flash memory consists of one or more blocks. Each block contains a number of sectors.
Sector is usually smallest erasable unit. The size of the sector depends on the CPU type
(the actual value of  the sector size is available as a constant in the component header file, please see <a href="IntFLASHUser Types.html">Types and constants page</a>).
The user can choose one the following ways of handling write operations (property <a href="IntFLASHProperties.html#WriteMethod">Write Method</a>):
<ul>
<li>
<B>Write</B> - No erase options are available. Data are written into FLASH without any tests. Only erased bits are affected.
Any of erase methods must be used (e.g <a href="IntFLASHMethods.html#EraseSector">EraseSector</a>) before write or the user must be sure that the flash is already erased.
</li>
<li>
<B>Destructive write (with erase)</B> - The whole sector is erased (if necessary) without any data backup and
then data is written into the FLASH.
</li>
<li>
<B>Safe write (with save & erase)</B> - If sector erase is necessary, data from sector are stored into a buffer in RAM,
sector is erased and data are restored back, and then new data are written into erased area.
This option could lead to compiler or runtime errors on derivatives where the RAM is not large enough for the buffer.
</li>
</ul>
</p>
<p>
The component offers the following features (if they are supported by the hardware -
please see the version specific notes in this document):
</p>

<ul>
<li><p><b>Simple access to individual items</b><br/>
    The component provides simple methods allowing to directly read/write individual bytes/words/longs
    (<a href="IntFLASHMethods.html#SetByteFlash">SetByteFlash</a>, <a href="IntFLASHMethods.html#GetByteFlash">GetByteFlash</a> etc.).
    </p>
</li>

<li><p><b>Virtual page</b><br/>
    The virtual page is an array located in RAM and the content of the whole array can be transferred
    between this virtual page and flash by using the methods <a href="IntFLASHMethods.html#SetPage">SetPage</a> and <a href="IntFLASHMethods.html#GetPage">GetPage</a>.
    Individual bytes of the virtual page can be accessed by using the methods
    <a href="IntFLASHMethods.html#GetBytePage">GetBytePage</a>,
    <a href="IntFLASHMethods.html#SetBytePage">SetBytePage</a>,
    <a href="IntFLASHMethods.html#GetWordPage">GetWordPage</a>,
    <a href="IntFLASHMethods.html#SetWordPage">SetWordPage</a>,
    <a href="IntFLASHMethods.html#GetLongPage">GetWordPage</a>,
    <a href="IntFLASHMethods.html#SetLongPage">SetWordPage</a>.
    See also event <a href="IntFLASHEvents.html#OnWritePageEnd">OnWritePageEnd</a>.
    </p>
</li>

<li><p><b>Methods can wait for the end of the operation or exit immediately</b><br/>
    The write methods can wait until the writing is finished or exit immediately. This option
    can be controlled at runtime by the <a href="IntFLASHMethods.html#SetWait">SetWait</a> method and
    the <a href="IntFLASHMethods.html#Busy">Busy</a> method can be used for the detection whether the flash memory
    is ready for the next operation or not.
    </p>
</li>

<li><p><b>Interrupt or polling based implementation</b><br/>
    If the interrupt support property is enabled, the <a href="IntFLASHEvents.html#OnWriteEnd">OnWriteEnd</a> and
    <a href="IntFLASHEvents.html#OnWritePageEnd">OnWritePageEnd</a> (if the virtual page is enabled) events
    are available. These events are invoked when the write operation finishes.
    </p>
</li>

<li><b>Block access</b><br/>

The component provides methods for reading/writing continuous data blocks: <a href="IntFLASHMethods.html#SetBlockFlash">SetBlockFlash</a>, <a href="IntFLASHMethods.html#GetBlockFlash">GetBlockFlash</a>.
</li>

</ul>
<p/>

<B><U>Addressing</U></B><p/>
The component uses special type <a href="IntFLASHUser Types.html#TAddress">TAddress</a>, which depends on the current CPU and its addressing mode (usually it is unsigned 16-bit or 32-bit integer).
It is possible to use component methods <a href="IntFLASHMethods.html#DataPtr2Addr">DataPtr2Addr</a> and <a href="IntFLASHMethods.html#FuncPtr2Addr">FuncPtr2Addr</a> to convert pointer to the correct TAddress value.
<p/>
<B><U>Recommendation with respect to programming phrase</U></B><p/>
Care must be taken to programming phrase length, i.e. the number of bytes that needs to be programmed to the Flash memory at once. (see ComponentName_PROGRAMMING_PHRASE constant in the header file) especially, if cumulative programming is not allowed by the silicon producer (ComponentName_ALLOW_CLEAR constant in the header file). It is recommended to write at once as much data as possible. If all data are available at once, it is recommended to use SetBlockFlash method to store all data to the Flash memory. If data need to be gathered for some time, use Virtual page to store them in RAM and then SetPage method to write all data at once to the Flash memory. SetByteFlash, SetWordFlash, SetLongFlash methods usage shall be limited to either when only one, two resp. four bytes need to be stored, or consecutive storage addresses don't overlap with programming phrase.
<p/>

<div class="versionspec">

<B CLASS="VSP">Version specific information for Freescale HCS12 and HCS12X derivatives:</B>
<br/>
<br/>
The component's methods employ 24-bit addressing scheme for the all memory models. For HCS12 derivatives (except those with P-Flash module), the first byte determines the page number, next two bytes represent the physical address
in the window page of the flash memory. For HCS12X derivatives and derivatives with P-Flash module, 24-bit Address method parameter is a global address. For both HCS12 and HCS12X, <a href="IntFLASHMethods.html#SetPage">SetPage</a>, <a href="IntFLASHMethods.html#SetWordFlash">SetWordFlash</a>,
<a href="IntFLASHMethods.html#GetWordFlash">GetWordFlash</a>, <a href="IntFLASHMethods.html#SetBlockFlash">SetBlockFlash</a> and <a href="IntFLASHMethods.html#GetBlockFlash">GetBlockFlash</a> methods require
the address to be word aligned. <a href="IntFLASHMethods.html#SetLongFlash">SetLongFlash</a> and <a href="IntFLASHMethods.html#GetLongFlash">GetLongFlash</a> methods require
the address to be long (four-bytes) aligned. <a href="IntFLASHMethods.html#SetBlockFlash">SetBlockFlash</a> and <a href="IntFLASHMethods.html#GetBlockFlash">GetBlockFlash</a> methods require
the number of written/read bytes to be an even number.
Some methods operate with entire blocks of the flash memory and therefore require the block number as a parameter. If the CPU flash contains only one block
 this parameter is ignored.
<BR/>If it is necessary to modify the flash memory the actual program is running from (especially if it is the same block - see documentation of the CPU),
then the <a href="IntFLASHProperties.html#WaitInRAM">Wait in RAM</a> property has to be set to "yes" to ensure proper function of the programming/erasing methods.
<BR/>Waiting till the end of write/erase operation can be disabled (not if <a href="IntFLASHProperties.html#WaitInRAM">Wait in RAM</a> mode is enabled).
<BR/>If property <a href="IntFLASHProperties.html#WriteMethod">Write Method</a> is set to "Safe Write", the component uses a memory buffer to store data temporarily. The buffer is
automatically allocated by the component in data RAM.
<BR/>Virtual page: The only supported option for <a href="IntFLASHProperties.html#VirtualPageType">Virtual page allocation</a> is "By the component".
<a href="IntFLASHMethods.html#SetPage">SetPage</a> and <a href="IntFLASHMethods.html#GetPage">GetPage</a> methods implement read/write
operations with the Virtual page. Care must be taken when storing the Virtual page, because the page must not be written over the boundary of a flash block.
<br/>
</div>
<div class="versionspec">

<B CLASS="VSP">Version specific information for Freescale HCS12(X) derivatives with P-Flash module and Emulated EEPROM:</B>
<p/>
The P-Flash memory constitutes the main nonvolatile memory store for applications - see the reference manual if the derivative contains P-Flash memory type.
<p/>
P-Flash memory requires that programming must be done on aligned 8 byte basis (a Flash phrase)
and only erased phrase can be programmed. This must be taken into account especially for 'Write' and 'Destructive write' programming modes.
Any attempt to rewrite once programmed phrase causes error in 'Write' mode (methods return error code ERR_VALUE) and in 'Destructive write' mode it causes sector erase. For example, if the program needs to write several bytes to the P-Flash memory at consecutive addresses in 'write' or 'destructive write' mode, usage of SetByteFlash, SetWordFlash, SetLongFlash methods is not recommended, unless storage is limited to only one, two, resp. four bytes. If all data is available, use SetBlockFlash to write all data at once to Flash memory. If data need to be gathered for some time, use Virtual page to store them in RAM and then SetPage method to write all data at once to the Flash memory.
</div>
<!---DESCEND DON'T CHANGE THIS-->
            </div>
           <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            Copyright 1997 - 2011 Freescale Semiconductor, Inc.
           </p> 
    </td>
  </tr>

</table>

</body>
</html>
