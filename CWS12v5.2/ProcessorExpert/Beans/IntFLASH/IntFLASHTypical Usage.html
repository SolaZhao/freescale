<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component documentation - Typical Usage
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>IntFLASH</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="IntFLASH.html">General Info</a><br />
<a href="IntFLASHProperties.html">Properties</a><br />
<a href="IntFLASHMethods.html">Methods</a><br />
<a href="IntFLASHEvents.html">Events</a><br />
<a href="IntFLASHUser Types.html">Types and constants</a><br />
<i>Typical Usage</i><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="IntFLASH_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%">

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              IntFLASH
            </div>
            <div class="descrtext">Internal FLASH</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">CPU Internal Peripherals-Memory</a>
              
              </span>
            </div>
          </div>
          
          <div class="text_title">
              Typical Usage:
      		</div>		 
    		  <div class="descr_line">                  
              (Examples of a typical usage of the component in user code.
               For more information please 
               see the page <a href="..\..\DOCs\BeanCodeTypicalUsage.html">Component Code 
               Typical Usage</a>.)                   
          </div>          

<div class="user_text">   
<br/>       
<!---DESCBEG DON'T CHANGE THIS-->
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
In our examples we expect that there is an empty flash sector at 0xE000 address.
It is also expected, that affected FLASH memory area is not protected. Please refer to CPU datasheet for details about protection.
The user has to properly choose the address in the flash for writing the data and ensure that sector that will be over-written
does not contain an application code or data, because the whole sector may be erased and lost.
This can be done for example, by decreasing the size of the area where the code is stored by the size of one or more
sectors that will be used for user's data. To adjust the allocation sizes, open the build options tab in CPU inspector.

<P/>Typical usage examples:</FONT><br/>

<!--- 1 -->
<P>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<B>(1)</B>
<BR/>Simple read and write of internal FLASH memory.
<P/>Required component settings:
<UL>
<LI> Component name: IntF1</LI>
<LI> Write mode: following options can be used</LI>
<UL>
<LI> Safe Write - will overwrite only specified location, sector will be automatically erased and data restored (EraseSector method is not necessary)</LI>
<LI> Destructive Write - whole sector will be automatically erased before write (EraseSector method is not necessary)</LI>
<LI> Write - it is necessare to use EraseSector method before write or ensure the location is erased before write</LI>
</UL>
</UL>
</FONT>
<PRE>
 <I><U>MAIN.C</U></I>

byte Data;
byte Err;

void main(void)
{
  /* Erase whole sector - necessary only if Write mode property is set to "Write" */
  Err = IFsh1_EraseSector(0xE000);
  /* Write number 28 to address 0xE000 */
  Err = IntF1_SetByteFlash(0xE000, 28);
  /* Read contents of internal FLASH array on address
     0xE000 and write it to variable Data */
  Err = IntF1_GetByteFlash(0xE000, &Data);
  if(Err != ERR_OK){
    /* Handle error - possibly after each method call*/
  }

}
</PRE>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
    <i>Note: Address of FLASH is meant as absolute address, not index in FLASH array.</i>
</FONT>
</P>

<!--- 2 -->
<P>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<B>(2)</B>
<BR/>Write of multiple bytes to the internal FLASH memory.
<P/>Required component settings:
<UL>
<LI> Component name: IntF1</LI>
<LI> Write mode: following options can be used</LI>
<UL>
<LI> Safe Write - will overwrite only specified location, sector will be automatically erased and data restored (EraseSector method is not necessary)</LI>
<LI> Destructive Write - whole sector will be automatically erased before write (EraseSector method is not necessary)</LI>
<LI> Write - it is necessare to use EraseSector method before write or ensure the location is erased before write</LI>
</UL>
</UL>
</FONT>
<PRE>
 <I><U>MAIN.C</U></I>

byte Test_data[] = {0x00,0x0B,0xCC,0x40,0x01,0x40,0x01,0x5B,
                    0x13,0x79,0x00,0x11,0x50,0x7B,0x01,0x21,
                    0x5A,0x1C,0x79,0x00,0x39,0xC6,0x81,0x5B,
                    0x3A,0xC6,0x10,0x7b,0x02,0xF0,0x06,0xC1,
                    0x1B,0x00};   
byte Err;

void main(void)
{
  /* Erase whole sector - necessary only if Write mode property is set to "Write" */
  Err = IFsh1_EraseSector(0xE000);
  /* Write data to addressess starting with 0xE000 */
  Err = IntF1_SetBlockFlash(&test_program_data[0],0xE000,sizeof(Test_data));
  if(Err != ERR_OK){
    /* Handle error - possibly after each method call*/
  }
}
</PRE>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
    <i>Note: Address of FLASH is meant as absolute address, not index in FLASH array.</i>
</FONT>
</P>

<!--- 3 -->

<P>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<B>(3)</B>
<BR/>If 'Virtual page' property is enabled, methods using virtual page
    are available. The following example reads data content of some FLASH area, modifies it,
    and stores it in other place in FLASH. Note: return values (error) testing is omited to simplify the example (see example (1) or (2)).
<P/>Required component settings:
<UL>
<LI> Component name: IntF1</LI>
<LI> Write mode: Safe Write</LI>
<LI> Virtual page: Enabled</LI>
</UL>
</FONT>
<PRE>
 <I><U>MAIN.C</U></I>


void main(void)
{

  // Fill virtual page with actual data content of address 0xE000
  IntF1_GetPage(0xE000);
  // Write number 23 to first cell of page
  IntF1_SetBytePage(0, 23);
  // Write number 255 to second cell
  IntF1_SetBytePage(1, 255);
  // Store data content of virtual page to FLASH on address 0xE630
  IntF1_SetPage(0xE630);

}
</PRE>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
    <i>Note: Method SetBytePage/GetBytePage use index 0 to PageSize-1</i></FONT>

</P>

<!--- 4 -->

<P>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<B>(4)</B>
<BR/>If <tt>Write method</tt> property is set to <tt>Safe write</tt> and user buffer is selected in <tt>Buffer type</tt> property,
it is necessary to implement events OnSaveBuffer and OnRestoreBuffer.
These events are called if flash sector erase operation is necessary for writing data into FLASH.
It is expected, that the user code saves/restores sector content during sector-erase operation.
<P/>
<I>The chart below shows a sequence of program flow during write opration if sector erase operation is required:</I>
<table><tr><td><img src="SafeWriteUserBuffer.png"/></td></tr></table>
<P/>
In the following example, sector content is copied into RAM <tt>LocBuffer</tt> variable in OnSaveBuffer event and it is restored in OnRestoreBuffer event. <br/>
Main contains "dummy" code, that causes sector erase. Note: return values (error) testing is omited to simplify the example (see example (1) or (2)).
<P/>Required component settings:
<UL>
<LI> Component name: IntF1</LI>
<LI> Write mode: Safe Write</LI>
<LI> Buffer type: Implemennted by user</LI>
</UL>
</FONT>
<PRE>
 <I><U>EVENTS.C</U></I>

#define MASK_ADDR_OFFSET (IntF1_AREA_0_SECTOR_SIZE - 1)
static byte LocBuffer[IntF1_AREA_0_SECTOR_SIZE];

void IntF1_OnSaveBuffer(IntF1_TAddress Addr, word Size)
{
  byte * Buf = &LocBuffer[Addr & MASK_ADDR_OFFSET];
  while (Size--) {
    (void)IntF1_GetByteFlash(Addr, Buf);
    Addr++;
    Buf++;
  } /* while Size */
}

void IntF1_OnRestoreBuffer(IntF1_TAddress Addr, word Size)
{
  (void)IntF1_RestoreToFlash(Addr, &LocBuffer[Addr & MASK_ADDR_OFFSET], Size);
}


 <I><U>MAIN.C</U></I>

void main(void)
{
  IntF1_SetByteFlash(0xE000, 0); /* clear */
  IntF1_SetByteFlash(0xE000, 1); /* sector erase operation will be required */
}
</PRE>

</P>

<!--- 5 -->

<P>
<FONT style="COLOR: #000000; FONT: 12px/18px Verdana, Geneva, Arial, Helvetica, sans-serif">
<B>(5)</B>
<BR/>DataPtr2Addr and FuncPtr2Addr method can be used to convert pointer to data respective pointer to function to an address, that may be passed as a parameter to write methods (SetByteFlash, SetWordFlash, etc.).
Example will demonstrate how to rewrite constant data in the Flash memory. Note: return values (error) testing is omited to simplify the example (see example (1) or (2)).
<P/>Required component settings:
<UL>
<LI> Component name: IntF1</LI>
<LI> Write mode: Safe Write</LI>
</UL>
</FONT>
<PRE>
 <I><U>MAIN.C</U></I>

const byte tab []@0xE000={
  1,2,3,4,5
};


void main(void)
{

  // rewrite first byte of constant variable tab
  IFsh1_SetByteFlash(IFsh1_DataPtr2Addr(tab),55);

}
</PRE>
</P>
<!---DESCEND DON'T CHANGE THIS-->
</div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            Copyright 1997 - 2011 Freescale Semiconductor, Inc.
          </p>
    </td>
  </tr>

</table>

</body>
</html>
