<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>DebugComm</Name>
  <Description>Interface FreescaleEthernetAPI\DebugComm for bean FreescaleEthernetAPI, generated by Bean Wizard</Description>
  <Author>Processor Expert / LU</Author>
  <Version>01.001</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Send one character to the channel. This method is available only if the transmitter property is enabled.\nDMA mode:\nIf DMA controller is available on selected CPU and transmitter is configured to use DMA controller then this method only sets selected DMA channel. Status of the DMA transfer can be then checked using method GetCharsInTxBuf. See typical usage for details about communication using DMA.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_TXFULL - Transmitter is full</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>TComData</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to send</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(%'ModuleName'_TComData Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>DebugComm</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TRecordType</UsrType>
      <Name>tItem</Name>
      <Hint>Item of the index table for possible baudrates</Hint>
      <Generate>yes</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef struct { /* Item of the index table for possible baudrates */\n    word div; /* divisior */\n    byte val; /* values of the prescalers */\n  } tItem;\n</PreparedHint>
      <RecordItem>
        <ItemName>div</ItemName>
        <ItemType>16bit unsigned</ItemType>
        <ItemHint>divisior</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>val</ItemName>
        <ItemType>8bit unsigned</ItemType>
        <ItemHint>values of the prescalers</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TError</Name>
      <Hint>Error flags. For languages which don't support bit access is byte access only to error flags possible.</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef union {\n  byte err;\n  struct {\n    bool OverRun : 1;   /* Overrun error flag */\n    bool Framing : 1;   /* Framing error flag */\n    bool Parity : 1;   /* Parity error flag */\n    bool RxBufOvf : 1;   /* Rx buffer full error flag */\n    bool Noise : 1;   /* Noise error flag */\n    bool Break : 1;   /* Break detect */\n    bool Idle : 1;   /* Idle character detect */\n  }errName;\n} %'ModuleName'_TError; /* Error flags. For languages which don't support bit access is byte access only to error flags possible. */\n</PreparedHint>
      <Type>typedef union {\n  byte err;\n  struct {\n    bool OverRun : 1;   %&gt;40/* Overrun error flag */\n    bool Framing : 1;   %&gt;40/* Framing error flag */\n    bool Parity : 1;   %&gt;40/* Parity error flag */\n    bool RxBufOvf : 1;   %&gt;40/* Rx buffer full error flag */\n    bool Noise : 1;   %&gt;40/* Noise error flag */\n    bool Break : 1;   %&gt;40/* Break detect */\n    bool Idle : 1;   %&gt;40/* Idle character detect */\n  }errName;\n} %'ModuleName'_TError;</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>TComData</Name>
      <Hint>User type for communication. Size of this type depends on the communication data witdh.</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef byte %'ModuleName'_TComData ;/* User type for communication. Size of this type depends on the communication data witdh. */\n</PreparedHint>
      <Type>8bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>TDirection</Name>
      <Hint/>
      <Generate>yes</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum {\n    TXD_INPUT,\n    TXD_OUTPUT\n  } TDirection;\n</PreparedHint>
      <EnumCount>2</EnumCount>
      <Enum>TXD_INPUT</Enum>
      <Enum>TXD_OUTPUT</Enum>
    </Type>
  </UserTypes>
</Interface>
