<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component documentation - General info
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>IntEEPROM</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<i>General Info</i><br />
<a href="IntEEPROMProperties.html">Properties</a><br />
<a href="IntEEPROMMethods.html">Methods</a><br />
<a href="IntEEPROMEvents.html">Events</a><br />
<a href="IntEEPROMUser Types.html">Types and constants</a><br />
<a href="IntEEPROMTypical Usage.html">Typical Usage</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="IntEEPROM_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%">

           <div class="titlebox">
              <div class="beanname">
                Component
                
                
                IntEEPROM
              </div>              
              <div class="descrtext">Internal EEPROM</div>
              <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
              <div class="info_name">Category: 
                <span class="info_text">
                <a href="../../DOCs/BeanCategoriesInfo.html">CPU Internal Peripherals-Memory</a>
                
                </span>
              </div>
            </div>
            <div class="user_text">
<!---DESCBEG DON'T CHANGE THIS-->
 This component implements access to an internal EEPROM of CPU.

<p>The component offers the following features (if they are supported by the hardware) :</p>

<ul>
<li><p><b>Simple byte access</b><br/>
    The component provides simple methods allowing to read/write individual bytes (<i>SetByte</i>, <i>GetByte</i> etc.)
    </p>
</li>

<li><b>Virtual page</b><br/>
    If the <a href="IntEEPROMProperties.html#PageSize">Page size</a> property is set to a value
    greater than zero, a virtual page is created. The virtual page is an array located in RAM and
    the content of the whole array can be transferred between this virtual page and EEPROM by
    using the methods <i><a href="IntEEPROMMethods.html#SetPage">SetPage</a></i> and <i><a href="IntEEPROMMethods.html#GetPage">GetPage</a></i>. Individual bytes of the virtual page can
    be accessed by using the methods <i><a href="IntEEPROMMethods.html#GetBytePage">GetBytePage</a>, <a href="IntEEPROMMethods.html#SetBytePage">SetBytePage</a></i> etc.
    <p/>
    The address pointer within the virtual page can be automatically pre-incremented
    if the methods <i><a href="IntEEPROMMethods.html#GetActBytePage">GetActBytePage</a>, <a href="IntEEPROMMethods.html#SetActBytePage">SetActBytePage</a></i> are used.
    The address pointer is set by methods <i><a href="IntEEPROMMethods.html#SetBytePage">SetBytePage</a>, <a href="IntEEPROMMethods.html#GetBytePage">GetBytePage</a></i>. 
        <div class="versionspec">
    <B CLASS="VSP">
    Version specific information for HCS12, HCS12(X) derivatives
    </B>
    <p>
    In case that address pointer is not inicialized by <i><a href="IntEEPROMMethods.html#SetBytePage">SetBytePage</a> or <a href="IntEEPROMMethods.html#GetBytePage">GetBytePage</a></i>
    method - <i><a href="IntEEPROMMethods.html#GetActBytePage">GetActBytePage</a>, and <a href="IntEEPROMMethods.html#SetActBytePage">SetActBytePage</a></i> methods returns ERR_RANGE.
    </p>
    </div>
            </li>

<li><p><b>Methods can wait for the end of the operation or exit immediatelly</b><br/>
    The write methods can wait until the writing is finished or exit immediatelly. This option
    can be controlled at runtime by the <i><a href="IntEEPROMMethods.html#SetWait">SetWait</a></i> method.
    The <i><a href="IntEEPROMMethods.html#Busy">Busy</a></i> method can be used for a detection, whether the EEPROM is ready for
    the next operation or not.
    </p>
</li>

<li><p><b>Interrupt based implementation</b><br/>
    If the EEPROM device support interrupt and <a href="IntEEPROMProperties.html#IntService">Interrupt service/event</a> property is
    enabled, the <i><a href="IntEEPROMEvents.html#OnWriteEnd">OnWriteEnd</a></i> and <i><a href="IntEEPROMEvents.html#OnWritePageEnd">OnWritePageEnd</a></i> events are available. These events
    are invoked from all write methods when the write operation finishes.
<div class="versionspec">
<B CLASS="VSP">
Version specific information for HCS12, HCS12X derivatives
</B>
      <p>
      The <i><a href="IntEEPROMMethods.html#SetProtection">SetProtection</a></i> method also invokes the <i><a href="IntEEPROMEvents.html#OnWriteEnd">OnWriteEnd</a></i> event because
      of writing the protection sector into the EEPROM array.
      </p>
</div>
</p>
</li>

<li><b>Automatic address increment</b><br/>
    The address pointer in the EEPROM can be automatically pre-incremented if the methods <i><a href="IntEEPROMMethods.html#GetActByte">GetActByte</a>, <a href="IntEEPROMMethods.html#SetActByte">SetActByte</a></i> are used.
    The address pointer is set by the methods using address as a parameter, such as <i><a href="IntEEPROMMethods.html#GetByte">GetByte</a>, <a href="IntEEPROMMethods.html#SetByte">SetByte</a>, <a href="IntEEPROMMethods.html#GetWord">GetWord</a>, <a href="IntEEPROMMethods.html#SetWord">SetWord</a>, <a href="IntEEPROMMethods.html#GetLong">GetLong</a>, <a href="IntEEPROMMethods.html#SetLong">SetLong</a></i>.
    Methods <i>GetPage, SetPage</i> set this pointer to the last address of the page.
    In the after-reset initialization code, the address pointer is set to the begin of the selected address range.
    <p/>
    See also automatic address increment for <i>Virtual page</i> described above.
<div class="versionspec">
<B CLASS="VSP">
Version specific information for HCS12, HCS12X, HCS08 derivatives
</B>
      <p>
    The address pointer is set also by the methods <a href="IntEEPROMMethods.html#EraseEeprom">EraseEeprom</a> and <a href="IntEEPROMMethods.html#EraseSector">EraseSector</a> to the address passed as a parameter - 1.
      </p>
</div>
</li>

</ul>
The user can choose one the following ways of handling write operations (property <a href="IntEEPROMProperties.html#WriteMethod">Write Method</a>):
<ul>
<li>
<B>Write</B> - No erase options are available. Data are written into EEPROM without any tests. Only erased bits are affected.
One of erase methods must be used (e.g <a href="IntEEPROMMethods.html#EraseSector">EraseSector</a>) before write or the user must be sure that the flash is already erased.
</li>
<li>
<B>Destructive write (with erase)</B> - The whole sector is erased (if necessary) without any data backup and
then data is written into the EEPROM.
</li>
<li>
<B>Safe write (with save & erase)</B> - If sector erase is necessary, data from sector are stored into a buffer in RAM,
sector is erased and data are restored back, and then new data are written into erased area.
This option could lead to compiler or runtime errors on derivatives where the RAM is not large enough for the buffer.
</li>
</ul>
<div class="versionspec">

<B CLASS="VSP">
Version specific information for HCS12, HCS12X derivatives
</B>
<p>
<b>Note:</b><br/>
As active commands are immediately aborted when the MCU enters stop mode, it is strongly recommended
that the user does not use the STOP instruction during program, sector erase, mass erase, or sector modify
operations.
</p>
</div>
<div class="text_title">Error Codes</div>

Methods for read/write operation to/from EEPROM can return the following error codes:
<UL>
<LI><B>ERR_BUSY</B> - device is busy (command was not completed)</LI>
<LI><B>ERR_RANGE</B> - operation access memory outside valid bounds</LI>
</UL>

<div class="versionspec">
<B CLASS="VSP">
Version specific information for HCS12, HCS12X derivatives
</B>
<br/>
<UL>
<LI><B>ERR_VALUE</B> - data verification failed</LI>
<LI><B>ERR_NOTAVAIL</B> - EEPROM Access Error (nonaligned address) or Protection Violation</LI>
</UL>
</div>
<div class="text_title">EEPROM memory mapping</div>
<p>
The component properties <a href="IntEEPROMProperties.html#EEPROM_StartAddr">Start address</a> and
<a href="IntEEPROMProperties.html#EEPROM_UsedSize">Used size</a> have to be configured properly for
a correct memory mapping.
Please note that the component allocates a memory range itself and it mustn't overlap with the EEPROM
memory segment defined in the build options tab of the CPU component (because it is not possible to use memory
both in the component and in the compiler). So if the component is used, corresponding memory area at build
options must be either disabled or adjusted respectively.
</p>

<div class="versionspec">

<B CLASS="VSP">
Version specific information for HCS12 derivatives
</B>
<br/>
<p>
Actual location of the internal EEPROM array in the CPU memory is also influenced by the <i>Internal
EEPROM mapping</i> property of the CPU component (see the <i>Internal resource mapping</i> group). It could
be necessary to check and properly adjust the <a href="IntEEPROMProperties.html#EEPROM_StartAddr">Start
address</a> property after changing the EEPROM mapping to ensure the correct memory mapping.
</p>
</div>
<div class="versionspec">

<B CLASS="VSP">
Version specific information for HCS12X derivatives and derivatives with D-Flash module
</B>
<p><div class="text_title">Global address space</div></p>
<p>
All HCS12X derivatives and derivatives with D-Flash module use global addressing scheme. The address parameter <i>"TAddress"</i> used in the component methods means the global address from the whole HCS12X CPU address space.
For example the address 0x13F000 is pointing to the start of the 4kB EEPROM array on the MC9S12XDP512_144 derivative.
</p>
For more details on the CPU global addressing scheme see the Memory mapping control chapter in pdf documentation of the CPU.
</div>
<div class="versionspec">

<B CLASS="VSP">
Version specific information for HCS12 and HCS12X derivatives
</B>
<p><div class="text_title">Address align</div></p>
SetPage and SetWord methods require the address to be word (two bytes) aligned.
SetLong method require the address to be long (four bytes) aligned.
SetPage method require the address to be long (four bytes) aligned, except for derivatives with Emulated EEPROM feature, where address must be word (two bytes) aligned.
</div>
<div class="versionspec">

<B CLASS="VSP">
Version specific information for HCS12X derivatives that supports Emulated EEPROM feature
</B>
<p><div class="text_title">D-Flash and buffer RAM Memory</div></p>
<p>
Before Emulated EEPROM can be used, D-Flash and Buffer RAM area must be partitioned. Partitions are defined by
<a href="IntEEPROMProperties.html#EEEfeatureGrp">Emulated EEPROM</a> properties (see help of the properties).
Partitioning will not take effect unless <a href="IntEEPROMMethods.html#Partition">Partition</a> method is called or
<a href="IntEEPROMProperties.html#PartitionInit">Partition D-flash in init</a> property is set (Partitions can be created only in special mode).
</p>
<p>
The range of addressess selected in <a href="IntEEPROMProperties.html#_AddrRangeGrp">Address range</a> properties is checked
when writting to corresponding area. The other memory range is set to maximum available memory,
i.e. when <a href="IntEEPROMProperties.html#_AddrRangeGrp">Address range</a> targets to D-Flash (D-Flash begins at global address 0x100000)
then selected range is checked on all writes to D-Flash, but maximum available buffer RAM range is checked on all writes to buffer RAM (end of Buffer RAM is at global address 0x13FFFF).
And vice versa, when <a href="IntEEPROMProperties.html#_AddrRangeGrp">Address range</a> targets to Buffer RAM
then selected range is checked on all writes to Buffer RAM, but maximum available D-Flash range is checked on all writes to D-Flash.
Size of buffer ram for Emulated EEPROM area is defined only by the property
"Buffer RAM sector count for Emulated EEPROM (ERPART)".
</p>
<p>
<a href="IntEEPROMMethods.html#EraseEeprom">EraseEeprom</a> method doesn't implement mass erase. Sector erase is used instead.
The method erases all available sectors for D-Flash user partition.
</p>
<p>
The memory type the component is writing to (D-Flash or Emulated EEPROM - buffer RAM) is determined by an Address passed as the parameter of SetXX/GetXX methods.
If the address targets to the buffer RAM, simple write to a RAM memory is performed and completed on exit of the write method, i.e. waiting settings selected by <a href="IntEEPROMMethods.html#SetWait">SetWait</a> method
or <a href="IntEEPROMProperties.html#InitEnableWait">Wait enabled in init.</a> property is not used (ignored) and Busy method returns always FALSE.
When a write to Buffer RAM (Emulated EEPROM) occurs, interrupts are not used and <a href="IntEEPROMEvents.html#OnWriteEnd">OnWriteEnd</a> and <a href="IntEEPROMEvents.html#OnWritePageEnd">OnWritePageEnd</a>
events are not invoked.
</p>
</div>
<!---DESCEND DON'T CHANGE THIS-->
            </div>
           <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            Copyright 1997 - 2011 Freescale Semiconductor, Inc.
           </p> 
    </td>
  </tr>

</table>

</body>
</html>
