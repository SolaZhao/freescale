<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component  documentation - Methods
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>SynchroSlave</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="SynchroSlave.html">General Info</a><br />
<a href="SynchroSlaveProperties.html">Properties</a><br />
<i>Methods</i><br />
<a href="SynchroSlaveEvents.html">Events</a><br />
<a href="SynchroSlaveUser Types.html">Types and constants</a><br />
<a href="SynchroSlaveTypical Usage.html">Typical Usage</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="SynchroSlave_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%" >

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              SynchroSlave
            </div>
            <div class="descrtext">Slave for synchronous serial communication</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">CPU Internal Peripherals-Communication</a>
              
              </span>
            </div>
          </div>

         <div class="text_title">
              Methods:
    		 </div>		 
    		 <div class="descr_line">                  
              (Methods are user-callable functions/subroutines intended for
               the component functions control. Please see the <a href="../../DOCs/EmbeddedBeans.html#Methods">Embedded Components page</a> for more information.)                   
         </div>
                  
         <div class="user_text">
            <ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<li><a name="Enable">
<b>Enable</b></a>
 - Enables the component - it starts send and receive functions. Events may be generated (&quot;DisableEvent&quot;/&quot;EnableEvent&quot;).
<ul>
<br /><i>ANSIC prototype:</i> byte Enable(void)<br />
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li><a name="Disable">
<b>Disable</b></a>
 - Disables the component - it stops the send and receive functions. No events will be generated. Note: When this method is called while a transmission is in progress, the data being transmitted/received may be lost.
<ul>
<br /><i>ANSIC prototype:</i> byte Disable(void)<br />
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li><a name="EnableEvent">
<b>EnableEvent</b></a>
 - Enables the events. This method is available only if the &quot;Interrupt service/event&quot; property is enabled and at least the one of events is set to generate code.
<ul>
<br /><i>ANSIC prototype:</i> byte EnableEvent(void)<br />
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li><a name="DisableEvent">
<b>DisableEvent</b></a>
 - Disables the events. This method is available only if the &quot;Interrupt service/event&quot; property is enabled and at least the one of events is set to generate code.
<ul>
<br /><i>ANSIC prototype:</i> byte DisableEvent(void)<br />
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li><a name="RecvChar">
<b>RecvChar</b></a>
 - If any data is received, this method returns one character, otherwise it returns an error code (it does not wait for data).
<p>
For information about SW overrun behavior please see <a href="SynchroSlave.html#SW_overrun_behavior">General info page</a>.
</p>
<ul>
<br /><i>ANSIC prototype:</i> byte RecvChar(<i>ComponentName_</i>TComData *Chr)<br />
<li><i>Chr: Pointer to <a href="SynchroSlaveUser Types.html#TComData"><i>ComponentName_</i>TComData</a></i> - A pointer to the received character</li>
<li><i>Return value:byte</i> - Error code, possible codes:<br />
     ERR_OK - OK<br />
     ERR_RXEMPTY - No data in receiver<br />
     ERR_OVERRUN - Overrun error is detected from the last char or block received. In polling mode, this error code is returned only when the hardware supports detection of the overrun error. If interrupt service is enabled, and input buffer allocated by the component is full, the component behaviour depends on <a href="SynchroSlaveProperties.html#InpBufferSize">Input buffer size</a> property : if property is 0, last received data-word is preserved (and previous is overwritten), if property is greater than 0, new received data-word are ignored.<br />
     ERR_FAULT - Fault error was detected from the last char or block received. This error does not need to be supported on some Cpu (see generated code).<br />
</li>
</ul><br />
</li>
<li><a name="SendChar">
<b>SendChar</b></a>
 - Sends one character to the channel.
<ul>
<br /><i>ANSIC prototype:</i> byte SendChar(<i>ComponentName_</i>TComData Chr)<br />
<li><i>Chr:<a href="SynchroSlaveUser Types.html#TComData"><i>ComponentName_</i>TComData</a></i> - Character to send</li>
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK<br />     ERR_DISABLED -  Device is disabled (only if output DMA is supported and enabled)<br />     ERR_TXFULL - Transmitter is full
</li>
</ul><br />
</li>
<li><a name="RecvBlock">
<b>RecvBlock</b></a>
 - If any data received, this method returns the block of the data and its length (and incidental error), otherwise it returns error code (it does not wait for data).<BR />
If less than requested number of characters is received only the available data is copied from the receive buffer to the user specified destination and the ERR_EXEMPTY value is returned.<BR />
This method is available only if non-zero length of input buffer is defined.
<p>
For information about SW overrun behavior please see <a href="SynchroSlave.html#SW_overrun_behavior">General info page</a>.
</p>
<ul>
<br /><i>ANSIC prototype:</i> byte RecvBlock(<i>ComponentName_</i>TComData *Ptr, word Size, word *Rcv)<br />
<li><i>Ptr: Pointer to <a href="SynchroSlaveUser Types.html#TComData"><i>ComponentName_</i>TComData</a></i> - A pointer to the block of received data</li>
<li><i>Size:word</i> - The size of the block</li>
<li><i>Rcv: Pointer to word</i> - Pointer to a variable where an actual number of copied characters is stored</li>
<li><i>Return value:byte</i> - Error code, possible codes:<br />
     ERR_OK - OK<br />
     ERR_RXEMPTY - It was not possible to read requested number of bytes from the buffer<br />
     ERR_OVERRUN - Overrun error was detected from the last char or block received. If interrupt service is enabled, and input buffer allocated by the component is full, the component behaviour depends on <a href="SynchroSlaveProperties.html#InpBufferSize">Input buffer size</a> property : if property is 0, last received data-word is preserved (and previous is overwritten), if property is greater than 0, new received data-word are ignored.<br />
     ERR_FAULT - Fault error was detected from the last char or block received. This error may not be supported on some Cpu (see generated code).<br />
</li>
</ul><br />
</li>
<li><a name="SendBlock">
<b>SendBlock</b></a>
 - Sends a block of characters to the channel. This method is only available if a non-zero length of output buffer is defined.
<ul>
<br /><i>ANSIC prototype:</i> byte SendBlock(<i>ComponentName_</i>TComData *Ptr, word Size, word *Snd)<br />
<li><i>Ptr: Pointer to <a href="SynchroSlaveUser Types.html#TComData"><i>ComponentName_</i>TComData</a></i> - Pointer to the block of data to send</li>
<li><i>Size:word</i> - Size of the block</li>
<li><i>Snd: Pointer to word</i> - Pointer to number of data that are sent (moved to buffer)</li>
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK<br />     ERR_DISABLED -  Device is disabled (only if output DMA is supported and enabled)<br />     ERR_TXFULL - It was not possible to send requested number of bytes
</li>
</ul><br />
</li>
<li><a name="ClearRxBuf">
<b>ClearRxBuf</b></a>
 - Clears the receive buffer. This method is available only if a non-zero length of input buffer is defined.
<ul>
<br /><i>ANSIC prototype:</i> byte ClearRxBuf(void)<br />
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li><a name="ClearTxBuf">
<b>ClearTxBuf</b></a>
 - Clears the transmit buffer. This method is only available if a non-zero length of output buffer is defined.
<ul>
<br /><i>ANSIC prototype:</i> byte ClearTxBuf(void)<br />
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li><a name="CharsInRxBuf">
<b>CharsInRxBuf</b></a>
 - Returns the number of characters in the input buffer.<BR />
Note: If the Interrupt service is disabled, and the Ignore empty character is set to yes, and a character has been received, then this method returns 1 although it was an empty character.<BR />
(deprecated method - Use the GetCharsInRxBuf method instead!)<BR />
<ul>
<br /><i>ANSIC prototype:</i> byte CharsInRxBuf(word *Chr)<br />
<li><i>Chr: Pointer to word</i> - A pointer to number of characters in the input buffer</li>
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li><a name="GetCharsInRxBuf">
<b>GetCharsInRxBuf</b></a>
 - Returns the number of characters in the input buffer.<br />
In <b>polling mode</b> (Interrupt service is disabled) if the peripheral does not support finding out number of data-word in its HW input buffer, the method returns 0 if the buffer is empty and returns 1 if the buffer is not empty.<br />
Note: If the Interrupt service is disabled, and the Ignore empty character is set to yes, and a character has been received, then this method returns 1 although it was an empty character.
<ul>
<br /><i>ANSIC prototype:</i> word GetCharsInRxBuf(void)<br />
<li><i>Return value:word</i> - Number of characters in the input buffer.
</li>
</ul><br />
</li>
<li><a name="CharsInTxBuf">
<b>CharsInTxBuf</b></a>
 - Returns the number of characters in the output buffer.<BR />
(deprecated method - Use the GetCharsInRxBuf method instead!)<BR />
<ul>
<br /><i>ANSIC prototype:</i> byte CharsInTxBuf(word *Chr)<br />
<li><i>Chr: Pointer to word</i> - A pointer to the number of characters in the output buffer</li>
<li><i>Return value:byte</i> - Error code, possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li><a name="GetCharsInTxBuf">
<b>GetCharsInTxBuf</b></a>
 - Returns the number of characters in the output buffer.
In <b>polling mode</b> (Interrupt service is disabled) if the peripheral does not support finding out number of data-word in its HW output buffer, the method returns 0 if the buffer is not full, and returns 1 if the buffer is full.<br />
<ul>
<br /><i>ANSIC prototype:</i> word GetCharsInTxBuf(void)<br />
<li><i>Return value:word</i> - Number of characters in the output buffer.
</li>
</ul><br />
</li>
<li><a name="GetError">
<b>GetError</b></a>
 - Returns a set of errors on the channel (errors that cannot be returned in given methods). The component accumulates errors in a set; after calling <b>GetError</b> this set is returned and cleared. This method is available only if the "Interrupt service/event" property is enabled.
<ul>
<br /><i>ANSIC prototype:</i> byte GetError(<i>ComponentName_</i>TError *Err)<br />
<li><i>Err: Pointer to <a href="SynchroSlaveUser Types.html#TError"><i>ComponentName_</i>TError</a></i> - A pointer to the returned set of errors</li>
<li><i>Return value:byte</i> - Error code (if GetError did not succeed), possible codes:<br />     ERR_OK - OK
</li>
</ul><br />
</li>
<li class="versionspec"><span class="versionspeclabel">Methods for ColdFireV1, HCS08, RS08, HCS12X and HCS12 derivatives.</span>
<ul>
<li><a name="SetDir">
<b>SetDir</b></a>
 - This method determines direction of data pin in bidirectional mode. The method is only available if 'Bidirectional mode' property is set to 'Enabled'.
<ul>
<br /><i>ANSIC prototype:</i> void SetDir(bool OutBuf)<br />
<li><i>OutBuf:bool</i> - Direction to set - <a href="..\..\DOCs\BeanCodeTypicalUsage.html#Bool">false</a>=Input, <a href="..\..\DOCs\BeanCodeTypicalUsage.html#Bool">true</a>=Output.</li>
</ul><br />
</li>
</ul>
</li>
           </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<p>
<br />
Note: Some methods can be implemented as macros.
</p>
          </div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            Copyright 1997 - 2010 Freescale Semiconductor, Inc.
          </p>
    </td>
  </tr>

</table>

</body>
</html>
