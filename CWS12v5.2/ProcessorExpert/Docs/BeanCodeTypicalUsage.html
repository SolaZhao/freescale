<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=us-ascii">

<title>
Typical Usage of Component in User Code
</title>
<LINK href="style.css" type="text/css" rel="stylesheet">
</head>
<body  style="margin-top:0px;margin-left:0px;margin-right:0px;"><table border="0" cellspacing="0" cellpadding="0" height="100%" width="100%">
  <tr>
  <td valign="top" width="150" >
    <table cellspacing="0" border="0">
      <tr>
        <td style="width:150;height:30;text-align:center;" class="leftTitleBox" >
          <span class="lefttitle" >User manual</span><br />
        </td>        
      </tr>
      <tr><td>&nbsp;<br/>
        <span class="leftmenu">
        </span>           
      </td>
      </tr>      
    </table>                
    <div style=";text-align:left;vertical-align:top;margin-left:4px;" >                                                
    <br/>
    </div>        

    </td>      
    <td width="1" class="splitterLine" valign="top">
      <div style="width:1px;height:100%"></div>
    </td>
    <td width="4">
    </td>
    <td style="vertical-align:top;padding-left:15px;padding-right:15px;padding-top:0px;">
<p class="pagetitle">Typical Usage of Component in User Code</p>
<div class="normal">
<p>This chapter describes usage of methods and events that are defined in most hardware oriented components. Usage of other component specific methods is described in the component documentation, in the section "Typical Usage" <i>(if available)</i>. </p><h2>Peripheral Initialization Components</h2><p><a href="BeanCategoriesInfo.html#LevelAbstraction">Peripheral Initialization Components</a> are the components at the lowest level of peripheral abstraction. These components contain only one method Init providing the initialization of the used peripheral.  See chapter <a href="BeanInitUsage.html">Typical Peripheral Initialization Components Usage</a> for details. </p><h2>High level components</h2><h3>Methods Enable, Disable</h3><p>Most of the hardware components support the methods Enable and Disable. These methods enable or disable peripheral functionality, which causes disabling of functionality of the component as well. <br /><i>Hint: Disabling of the peripheral functionality may save CPU resources.</i></p><p> Overview of the method behavior according to the component type: </p><ul><li class="normli">Timer components: timer counter is stopped if it is not shared with another component. If the timer is shared, the interrupt may be disabled (if it is not also shared).</li><li class="normli">Communication components, such as serial or CAN communication: peripheral is disabled.</li><li class="normli">Conversion components, such as A/D and D/A: converter is disabled. The conversion is restarted by Enable.</li></ul><p> If the component is disabled, some methods may not be used. Please refer to components documentation for details. </p><p><u><i>MAIN.C</i></u><pre>
  void main(void)
  {
    ...
    B1_Enable();   /* enable the component functionality */
                /* handle the component data or settings */
    B1_Disable(); /* disable the component functionality */
    ...
  }
  </pre></p><h3>Methods EnableEvent, DisableEvent</h3><p> These methods enable or disable invocation of all component events. These methods are usually supported only if the component services any interrupt vector. </p><p> The method DisableEvent may cause disabling of the interrupt, if it is not required by the component functionality or shared with another component. The method usually does not disable either peripheral or the component functionality. </p><p><u><i>MAIN.C</i></u><pre>
  void main(void)
  {
    ...
    B1_EnableEvent();  /* enable the component events */
                       /* component events may be invoked */
    B1_DisableEvent(); /* disable the component events */
                       /* component events are disabled */
    ...
  }
  </pre></p><h3>Events BeforeNewSpeed, AfterNewSpeed</h3><p>Timed components that depend on the CPU clock such as timers, communication and conversion components, may support speed modes defined in the CPU component (in EXPERT view level). The event BeforeNewSpeed is invoked before the speed mode changes and AfterNewSpeed is invoked after the speed mode changes. Speed mode may be changed using the CPU component methods SetHigh, SetLow, or SetSlow. </p><p><u><i>EVENT.C</i></u><pre>
  int changing_speed_mode = 0;

  void B1_BeforeNewSpeed(void)
  {
    ++changing_speed_mode;
  }

  void B1_AfterNewSpeed(void)
  {
    --changing_speed_mode;
  }
  </pre></p><p>Note: If the speed mode is not supported by the component, the component functionality is disabled, as if the method Disable is used. If the supported speed mode is selected again, the component status is restored. </p><a name="Bool"></a><h2>TRUE and FALSE Values of bool Type</h2><p>Processor Expert defines the TRUE symbol as 1, however true and false logical values in C language are defined according to ANSI-C: <ul><li class="normli">False is defined as 0 (zero)</li><li class="normli">True is any non-zero value</li></ul><br /> It follows from this definition, that the bool value cannot be tested using the expressions, such as <tt>if (value == TRUE) ...</tt><br /> Processor Expert methods returning bool value often benefit from this definition and they return any non-zero value as TRUE value instead of 1. The correct C expression for such test is: <b><tt tag="tt">if (value) ...</tt></b>. </p><p><span class="note">In our documentation, the "true" or "false" are considered as logical states, not any particular numeric values. The capitalized "TRUE" and "FALSE" are constants defined as FALSE=0 and TRUE=1. </span></p></div>
<div class="copyright" style="text-align:center"> Copyright 2011 Freescale Semiconductor, Inc.<br /> PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc. </div>

  </td>
  </tr>
</table>

</body>
</html>
